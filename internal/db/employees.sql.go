// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: employees.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const closeEmployeeValidPeriod = `-- name: CloseEmployeeValidPeriod :exec
UPDATE employees 
SET valid_to = ?
WHERE emp_no = ?
  AND valid_to = '9999-12-31 23:59:59'
`

type CloseEmployeeValidPeriodParams struct {
	ValidTo time.Time `json:"valid_to"`
	EmpNo   int64     `json:"emp_no"`
}

// Update employee (bitemporal update - close current record and insert new)
// This is typically done in application logic, but this closes the current valid period
func (q *Queries) CloseEmployeeValidPeriod(ctx context.Context, arg CloseEmployeeValidPeriodParams) error {
	_, err := q.db.ExecContext(ctx, closeEmployeeValidPeriod, arg.ValidTo, arg.EmpNo)
	return err
}

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO employees (
  emp_no, birth_date, first_name, last_name, gender, hire_date, valid_from, valid_to
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING emp_no, birth_date, first_name, last_name, gender, hire_date, valid_from, valid_to, transaction_time
`

type CreateEmployeeParams struct {
	EmpNo     int64     `json:"emp_no"`
	BirthDate time.Time `json:"birth_date"`
	FirstName string    `json:"first_name"`
	LastName  string    `json:"last_name"`
	Gender    string    `json:"gender"`
	HireDate  time.Time `json:"hire_date"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Create new employee (insert with current transaction time)
func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (Employee, error) {
	row := q.db.QueryRowContext(ctx, createEmployee,
		arg.EmpNo,
		arg.BirthDate,
		arg.FirstName,
		arg.LastName,
		arg.Gender,
		arg.HireDate,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i Employee
	err := row.Scan(
		&i.EmpNo,
		&i.BirthDate,
		&i.FirstName,
		&i.LastName,
		&i.Gender,
		&i.HireDate,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const deleteEmployee = `-- name: DeleteEmployee :exec
UPDATE employees 
SET valid_to = ?
WHERE emp_no = ?
  AND valid_to = '9999-12-31 23:59:59'
`

type DeleteEmployeeParams struct {
	ValidTo time.Time `json:"valid_to"`
	EmpNo   int64     `json:"emp_no"`
}

// Logical delete (close valid period)
func (q *Queries) DeleteEmployee(ctx context.Context, arg DeleteEmployeeParams) error {
	_, err := q.db.ExecContext(ctx, deleteEmployee, arg.ValidTo, arg.EmpNo)
	return err
}

const getEmployeeAsOfTransaction = `-- name: GetEmployeeAsOfTransaction :one
SELECT emp_no, birth_date, first_name, last_name, gender, hire_date, valid_from, valid_to, transaction_time FROM employees
WHERE emp_no = ?
  AND transaction_time <= ?
  AND valid_from <= ?
  AND valid_to > ?
ORDER BY transaction_time DESC
LIMIT 1
`

type GetEmployeeAsOfTransactionParams struct {
	EmpNo           int64        `json:"emp_no"`
	TransactionTime sql.NullTime `json:"transaction_time"`
	ValidFrom       time.Time    `json:"valid_from"`
	ValidTo         time.Time    `json:"valid_to"`
}

// Get employee as it was known at a specific transaction time (time travel)
func (q *Queries) GetEmployeeAsOfTransaction(ctx context.Context, arg GetEmployeeAsOfTransactionParams) (Employee, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeAsOfTransaction,
		arg.EmpNo,
		arg.TransactionTime,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i Employee
	err := row.Scan(
		&i.EmpNo,
		&i.BirthDate,
		&i.FirstName,
		&i.LastName,
		&i.Gender,
		&i.HireDate,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const getEmployeeCurrent = `-- name: GetEmployeeCurrent :one

SELECT emp_no, birth_date, first_name, last_name, gender, hire_date, valid_from, valid_to, transaction_time FROM employees
WHERE emp_no = ? 
  AND valid_from <= ? 
  AND valid_to > ?
ORDER BY transaction_time DESC
LIMIT 1
`

type GetEmployeeCurrentParams struct {
	EmpNo     int64     `json:"emp_no"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Bitemporal Employee Queries
// Get current version of employee (as of specific valid time)
func (q *Queries) GetEmployeeCurrent(ctx context.Context, arg GetEmployeeCurrentParams) (Employee, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeCurrent, arg.EmpNo, arg.ValidFrom, arg.ValidTo)
	var i Employee
	err := row.Scan(
		&i.EmpNo,
		&i.BirthDate,
		&i.FirstName,
		&i.LastName,
		&i.Gender,
		&i.HireDate,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const getEmployeeDepartmentTimeline = `-- name: GetEmployeeDepartmentTimeline :many
SELECT 
  'department' as change_type,
  de.valid_from as change_date,
  'Department: ' || d.dept_name as description,
  de.transaction_time
FROM dept_emp de
JOIN departments d ON de.dept_no = d.dept_no
WHERE de.emp_no = ?
ORDER BY de.valid_from DESC, de.transaction_time DESC
`

type GetEmployeeDepartmentTimelineRow struct {
	ChangeType      string       `json:"change_type"`
	ChangeDate      time.Time    `json:"change_date"`
	Description     interface{}  `json:"description"`
	TransactionTime sql.NullTime `json:"transaction_time"`
}

// Get employee department history
func (q *Queries) GetEmployeeDepartmentTimeline(ctx context.Context, empNo int64) ([]GetEmployeeDepartmentTimelineRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeDepartmentTimeline, empNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeeDepartmentTimelineRow
	for rows.Next() {
		var i GetEmployeeDepartmentTimelineRow
		if err := rows.Scan(
			&i.ChangeType,
			&i.ChangeDate,
			&i.Description,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeHistory = `-- name: GetEmployeeHistory :many
SELECT emp_no, birth_date, first_name, last_name, gender, hire_date, valid_from, valid_to, transaction_time FROM employees
WHERE emp_no = ?
ORDER BY valid_from, transaction_time
`

// Get complete history of employee changes
func (q *Queries) GetEmployeeHistory(ctx context.Context, empNo int64) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeHistory, empNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmpNo,
			&i.BirthDate,
			&i.FirstName,
			&i.LastName,
			&i.Gender,
			&i.HireDate,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeSalaryTimeline = `-- name: GetEmployeeSalaryTimeline :many
SELECT 
  'salary' as change_type,
  s.valid_from as change_date,
  'Salary: $' || s.salary as description,
  s.transaction_time
FROM salaries s
WHERE s.emp_no = ?
ORDER BY s.valid_from DESC, s.transaction_time DESC
`

type GetEmployeeSalaryTimelineRow struct {
	ChangeType      string       `json:"change_type"`
	ChangeDate      time.Time    `json:"change_date"`
	Description     interface{}  `json:"description"`
	TransactionTime sql.NullTime `json:"transaction_time"`
}

// Get employee salary history
func (q *Queries) GetEmployeeSalaryTimeline(ctx context.Context, empNo int64) ([]GetEmployeeSalaryTimelineRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeSalaryTimeline, empNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeeSalaryTimelineRow
	for rows.Next() {
		var i GetEmployeeSalaryTimelineRow
		if err := rows.Scan(
			&i.ChangeType,
			&i.ChangeDate,
			&i.Description,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeTimeline = `-- name: GetEmployeeTimeline :many
SELECT 
  e.emp_no,
  e.first_name,
  e.last_name,
  s.salary,
  s.valid_from as salary_valid_from,
  s.valid_to as salary_valid_to,
  t.title,
  t.valid_from as title_valid_from,
  t.valid_to as title_valid_to,
  d.dept_name,
  de.valid_from as dept_valid_from,
  de.valid_to as dept_valid_to,
  CASE WHEN dm.emp_no IS NOT NULL THEN d.dept_name ELSE NULL END as managed_dept,
  dm.valid_from as manager_valid_from,
  dm.valid_to as manager_valid_to
FROM employees e
LEFT JOIN salaries s ON e.emp_no = s.emp_no
LEFT JOIN titles t ON e.emp_no = t.emp_no
LEFT JOIN dept_emp de ON e.emp_no = de.emp_no
LEFT JOIN departments d ON de.dept_no = d.dept_no
LEFT JOIN dept_manager dm ON e.emp_no = dm.emp_no
WHERE e.emp_no = ?
  AND e.valid_from <= ? AND e.valid_to > ?
ORDER BY 
  COALESCE(s.valid_from, '1900-01-01') DESC,
  COALESCE(t.valid_from, '1900-01-01') DESC,
  COALESCE(de.valid_from, '1900-01-01') DESC,
  COALESCE(dm.valid_from, '1900-01-01') DESC
`

type GetEmployeeTimelineParams struct {
	EmpNo     int64     `json:"emp_no"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

type GetEmployeeTimelineRow struct {
	EmpNo            int64          `json:"emp_no"`
	FirstName        string         `json:"first_name"`
	LastName         string         `json:"last_name"`
	Salary           sql.NullInt64  `json:"salary"`
	SalaryValidFrom  sql.NullTime   `json:"salary_valid_from"`
	SalaryValidTo    sql.NullTime   `json:"salary_valid_to"`
	Title            sql.NullString `json:"title"`
	TitleValidFrom   sql.NullTime   `json:"title_valid_from"`
	TitleValidTo     sql.NullTime   `json:"title_valid_to"`
	DeptName         sql.NullString `json:"dept_name"`
	DeptValidFrom    sql.NullTime   `json:"dept_valid_from"`
	DeptValidTo      sql.NullTime   `json:"dept_valid_to"`
	ManagedDept      interface{}    `json:"managed_dept"`
	ManagerValidFrom sql.NullTime   `json:"manager_valid_from"`
	ManagerValidTo   sql.NullTime   `json:"manager_valid_to"`
}

// Get complete employee timeline with all changes (using JOINs)
func (q *Queries) GetEmployeeTimeline(ctx context.Context, arg GetEmployeeTimelineParams) ([]GetEmployeeTimelineRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeTimeline, arg.EmpNo, arg.ValidFrom, arg.ValidTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeeTimelineRow
	for rows.Next() {
		var i GetEmployeeTimelineRow
		if err := rows.Scan(
			&i.EmpNo,
			&i.FirstName,
			&i.LastName,
			&i.Salary,
			&i.SalaryValidFrom,
			&i.SalaryValidTo,
			&i.Title,
			&i.TitleValidFrom,
			&i.TitleValidTo,
			&i.DeptName,
			&i.DeptValidFrom,
			&i.DeptValidTo,
			&i.ManagedDept,
			&i.ManagerValidFrom,
			&i.ManagerValidTo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeTitleTimeline = `-- name: GetEmployeeTitleTimeline :many
SELECT 
  'title' as change_type,
  t.valid_from as change_date,
  t.valid_to as end_date,
  'Title: ' || t.title as description,
  t.transaction_time
FROM titles t
WHERE t.emp_no = ?
ORDER BY t.valid_from DESC, t.transaction_time DESC
`

type GetEmployeeTitleTimelineRow struct {
	ChangeType      string       `json:"change_type"`
	ChangeDate      time.Time    `json:"change_date"`
	EndDate         time.Time    `json:"end_date"`
	Description     interface{}  `json:"description"`
	TransactionTime sql.NullTime `json:"transaction_time"`
}

// Get employee title history
func (q *Queries) GetEmployeeTitleTimeline(ctx context.Context, empNo int64) ([]GetEmployeeTitleTimelineRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeTitleTimeline, empNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeeTitleTimelineRow
	for rows.Next() {
		var i GetEmployeeTitleTimelineRow
		if err := rows.Scan(
			&i.ChangeType,
			&i.ChangeDate,
			&i.EndDate,
			&i.Description,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeWithCurrentDetails = `-- name: GetEmployeeWithCurrentDetails :one
SELECT 
  e.emp_no, e.first_name, e.last_name, e.birth_date, e.gender, e.hire_date,
  s.salary,
  t.title,
  d.dept_no, d.dept_name,
  CASE WHEN dm.emp_no IS NOT NULL THEN true ELSE false END as is_manager
FROM employees e
LEFT JOIN salaries s ON e.emp_no = s.emp_no
  AND s.valid_from <= ? AND s.valid_to > ?
LEFT JOIN titles t ON e.emp_no = t.emp_no
  AND t.valid_from <= ? AND t.valid_to > ?
LEFT JOIN dept_emp de ON e.emp_no = de.emp_no
  AND de.valid_from <= ? AND de.valid_to > ?
LEFT JOIN departments d ON de.dept_no = d.dept_no
  AND d.valid_from <= ? AND d.valid_to > ?
LEFT JOIN dept_manager dm ON e.emp_no = dm.emp_no
  AND dm.valid_from <= ? AND dm.valid_to > ?
WHERE e.emp_no = ?
  AND e.valid_from <= ? AND e.valid_to > ?
ORDER BY s.transaction_time DESC, t.transaction_time DESC, de.transaction_time DESC
LIMIT 1
`

type GetEmployeeWithCurrentDetailsParams struct {
	ValidFrom   time.Time `json:"valid_from"`
	ValidTo     time.Time `json:"valid_to"`
	ValidFrom_2 time.Time `json:"valid_from_2"`
	ValidTo_2   time.Time `json:"valid_to_2"`
	ValidFrom_3 time.Time `json:"valid_from_3"`
	ValidTo_3   time.Time `json:"valid_to_3"`
	ValidFrom_4 time.Time `json:"valid_from_4"`
	ValidTo_4   time.Time `json:"valid_to_4"`
	ValidFrom_5 time.Time `json:"valid_from_5"`
	ValidTo_5   time.Time `json:"valid_to_5"`
	EmpNo       int64     `json:"emp_no"`
	ValidFrom_6 time.Time `json:"valid_from_6"`
	ValidTo_6   time.Time `json:"valid_to_6"`
}

type GetEmployeeWithCurrentDetailsRow struct {
	EmpNo     int64          `json:"emp_no"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	BirthDate time.Time      `json:"birth_date"`
	Gender    string         `json:"gender"`
	HireDate  time.Time      `json:"hire_date"`
	Salary    sql.NullInt64  `json:"salary"`
	Title     sql.NullString `json:"title"`
	DeptNo    sql.NullString `json:"dept_no"`
	DeptName  sql.NullString `json:"dept_name"`
	IsManager int64          `json:"is_manager"`
}

// Get employee with current salary, title, and department
func (q *Queries) GetEmployeeWithCurrentDetails(ctx context.Context, arg GetEmployeeWithCurrentDetailsParams) (GetEmployeeWithCurrentDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeWithCurrentDetails,
		arg.ValidFrom,
		arg.ValidTo,
		arg.ValidFrom_2,
		arg.ValidTo_2,
		arg.ValidFrom_3,
		arg.ValidTo_3,
		arg.ValidFrom_4,
		arg.ValidTo_4,
		arg.ValidFrom_5,
		arg.ValidTo_5,
		arg.EmpNo,
		arg.ValidFrom_6,
		arg.ValidTo_6,
	)
	var i GetEmployeeWithCurrentDetailsRow
	err := row.Scan(
		&i.EmpNo,
		&i.FirstName,
		&i.LastName,
		&i.BirthDate,
		&i.Gender,
		&i.HireDate,
		&i.Salary,
		&i.Title,
		&i.DeptNo,
		&i.DeptName,
		&i.IsManager,
	)
	return i, err
}

const getEmployeesByDepartmentWithDetails = `-- name: GetEmployeesByDepartmentWithDetails :many
SELECT 
  e.emp_no, e.first_name, e.last_name,
  s.salary,
  t.title,
  d.dept_name,
  CASE WHEN dm.emp_no IS NOT NULL THEN true ELSE false END as is_manager
FROM employees e
JOIN dept_emp de ON e.emp_no = de.emp_no
JOIN departments d ON de.dept_no = d.dept_no
LEFT JOIN salaries s ON e.emp_no = s.emp_no
  AND s.valid_from <= ? AND s.valid_to > ?
LEFT JOIN titles t ON e.emp_no = t.emp_no
  AND t.valid_from <= ? AND t.valid_to > ?
LEFT JOIN dept_manager dm ON e.emp_no = dm.emp_no
  AND dm.valid_from <= ? AND dm.valid_to > ?
WHERE d.dept_no = ?
  AND e.valid_from <= ? AND e.valid_to > ?
  AND de.valid_from <= ? AND de.valid_to > ?
  AND d.valid_from <= ? AND d.valid_to > ?
ORDER BY s.salary DESC
`

type GetEmployeesByDepartmentWithDetailsParams struct {
	ValidFrom   time.Time `json:"valid_from"`
	ValidTo     time.Time `json:"valid_to"`
	ValidFrom_2 time.Time `json:"valid_from_2"`
	ValidTo_2   time.Time `json:"valid_to_2"`
	ValidFrom_3 time.Time `json:"valid_from_3"`
	ValidTo_3   time.Time `json:"valid_to_3"`
	DeptNo      string    `json:"dept_no"`
	ValidFrom_4 time.Time `json:"valid_from_4"`
	ValidTo_4   time.Time `json:"valid_to_4"`
	ValidFrom_5 time.Time `json:"valid_from_5"`
	ValidTo_5   time.Time `json:"valid_to_5"`
	ValidFrom_6 time.Time `json:"valid_from_6"`
	ValidTo_6   time.Time `json:"valid_to_6"`
}

type GetEmployeesByDepartmentWithDetailsRow struct {
	EmpNo     int64          `json:"emp_no"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Salary    sql.NullInt64  `json:"salary"`
	Title     sql.NullString `json:"title"`
	DeptName  string         `json:"dept_name"`
	IsManager int64          `json:"is_manager"`
}

// Get employees by department with salary and title info
func (q *Queries) GetEmployeesByDepartmentWithDetails(ctx context.Context, arg GetEmployeesByDepartmentWithDetailsParams) ([]GetEmployeesByDepartmentWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeesByDepartmentWithDetails,
		arg.ValidFrom,
		arg.ValidTo,
		arg.ValidFrom_2,
		arg.ValidTo_2,
		arg.ValidFrom_3,
		arg.ValidTo_3,
		arg.DeptNo,
		arg.ValidFrom_4,
		arg.ValidTo_4,
		arg.ValidFrom_5,
		arg.ValidTo_5,
		arg.ValidFrom_6,
		arg.ValidTo_6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeesByDepartmentWithDetailsRow
	for rows.Next() {
		var i GetEmployeesByDepartmentWithDetailsRow
		if err := rows.Scan(
			&i.EmpNo,
			&i.FirstName,
			&i.LastName,
			&i.Salary,
			&i.Title,
			&i.DeptName,
			&i.IsManager,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeesByHireDate = `-- name: GetEmployeesByHireDate :many
SELECT emp_no, birth_date, first_name, last_name, gender, hire_date, valid_from, valid_to, transaction_time FROM employees
WHERE hire_date BETWEEN ? AND ?
  AND valid_from <= ?
  AND valid_to > ?
ORDER BY hire_date
`

type GetEmployeesByHireDateParams struct {
	HireDate   time.Time `json:"hire_date"`
	HireDate_2 time.Time `json:"hire_date_2"`
	ValidFrom  time.Time `json:"valid_from"`
	ValidTo    time.Time `json:"valid_to"`
}

// Get employees hired in date range
func (q *Queries) GetEmployeesByHireDate(ctx context.Context, arg GetEmployeesByHireDateParams) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeesByHireDate,
		arg.HireDate,
		arg.HireDate_2,
		arg.ValidFrom,
		arg.ValidTo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmpNo,
			&i.BirthDate,
			&i.FirstName,
			&i.LastName,
			&i.Gender,
			&i.HireDate,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeesBySalaryRangeWithDetails = `-- name: GetEmployeesBySalaryRangeWithDetails :many
SELECT 
  e.emp_no, e.first_name, e.last_name,
  s.salary,
  t.title,
  d.dept_name,
  CASE WHEN dm.emp_no IS NOT NULL THEN true ELSE false END as is_manager
FROM employees e
JOIN salaries s ON e.emp_no = s.emp_no
LEFT JOIN titles t ON e.emp_no = t.emp_no
  AND t.valid_from <= ? AND t.valid_to > ?
LEFT JOIN dept_emp de ON e.emp_no = de.emp_no
  AND de.valid_from <= ? AND de.valid_to > ?
LEFT JOIN departments d ON de.dept_no = d.dept_no
  AND d.valid_from <= ? AND d.valid_to > ?
LEFT JOIN dept_manager dm ON e.emp_no = dm.emp_no
  AND dm.valid_from <= ? AND dm.valid_to > ?
WHERE s.salary BETWEEN ? AND ?
  AND e.valid_from <= ? AND e.valid_to > ?
  AND s.valid_from <= ? AND s.valid_to > ?
ORDER BY s.salary DESC
`

type GetEmployeesBySalaryRangeWithDetailsParams struct {
	ValidFrom   time.Time `json:"valid_from"`
	ValidTo     time.Time `json:"valid_to"`
	ValidFrom_2 time.Time `json:"valid_from_2"`
	ValidTo_2   time.Time `json:"valid_to_2"`
	ValidFrom_3 time.Time `json:"valid_from_3"`
	ValidTo_3   time.Time `json:"valid_to_3"`
	ValidFrom_4 time.Time `json:"valid_from_4"`
	ValidTo_4   time.Time `json:"valid_to_4"`
	Salary      int64     `json:"salary"`
	Salary_2    int64     `json:"salary_2"`
	ValidFrom_5 time.Time `json:"valid_from_5"`
	ValidTo_5   time.Time `json:"valid_to_5"`
	ValidFrom_6 time.Time `json:"valid_from_6"`
	ValidTo_6   time.Time `json:"valid_to_6"`
}

type GetEmployeesBySalaryRangeWithDetailsRow struct {
	EmpNo     int64          `json:"emp_no"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Salary    int64          `json:"salary"`
	Title     sql.NullString `json:"title"`
	DeptName  sql.NullString `json:"dept_name"`
	IsManager int64          `json:"is_manager"`
}

// Get employees by salary range with title and department info
func (q *Queries) GetEmployeesBySalaryRangeWithDetails(ctx context.Context, arg GetEmployeesBySalaryRangeWithDetailsParams) ([]GetEmployeesBySalaryRangeWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeesBySalaryRangeWithDetails,
		arg.ValidFrom,
		arg.ValidTo,
		arg.ValidFrom_2,
		arg.ValidTo_2,
		arg.ValidFrom_3,
		arg.ValidTo_3,
		arg.ValidFrom_4,
		arg.ValidTo_4,
		arg.Salary,
		arg.Salary_2,
		arg.ValidFrom_5,
		arg.ValidTo_5,
		arg.ValidFrom_6,
		arg.ValidTo_6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeesBySalaryRangeWithDetailsRow
	for rows.Next() {
		var i GetEmployeesBySalaryRangeWithDetailsRow
		if err := rows.Scan(
			&i.EmpNo,
			&i.FirstName,
			&i.LastName,
			&i.Salary,
			&i.Title,
			&i.DeptName,
			&i.IsManager,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeesByTitleWithDetails = `-- name: GetEmployeesByTitleWithDetails :many
SELECT 
  e.emp_no, e.first_name, e.last_name,
  s.salary,
  t.title,
  d.dept_name,
  CASE WHEN dm.emp_no IS NOT NULL THEN true ELSE false END as is_manager
FROM employees e
JOIN titles t ON e.emp_no = t.emp_no
LEFT JOIN dept_emp de ON e.emp_no = de.emp_no
  AND de.valid_from <= ? AND de.valid_to > ?
LEFT JOIN departments d ON de.dept_no = d.dept_no
  AND d.valid_from <= ? AND d.valid_to > ?
LEFT JOIN salaries s ON e.emp_no = s.emp_no
  AND s.valid_from <= ? AND s.valid_to > ?
LEFT JOIN dept_manager dm ON e.emp_no = dm.emp_no
  AND dm.valid_from <= ? AND dm.valid_to > ?
WHERE t.title = ?
  AND e.valid_from <= ? AND e.valid_to > ?
  AND t.valid_from <= ? AND t.valid_to > ?
ORDER BY s.salary DESC
`

type GetEmployeesByTitleWithDetailsParams struct {
	ValidFrom   time.Time `json:"valid_from"`
	ValidTo     time.Time `json:"valid_to"`
	ValidFrom_2 time.Time `json:"valid_from_2"`
	ValidTo_2   time.Time `json:"valid_to_2"`
	ValidFrom_3 time.Time `json:"valid_from_3"`
	ValidTo_3   time.Time `json:"valid_to_3"`
	ValidFrom_4 time.Time `json:"valid_from_4"`
	ValidTo_4   time.Time `json:"valid_to_4"`
	Title       string    `json:"title"`
	ValidFrom_5 time.Time `json:"valid_from_5"`
	ValidTo_5   time.Time `json:"valid_to_5"`
	ValidFrom_6 time.Time `json:"valid_from_6"`
	ValidTo_6   time.Time `json:"valid_to_6"`
}

type GetEmployeesByTitleWithDetailsRow struct {
	EmpNo     int64          `json:"emp_no"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Salary    sql.NullInt64  `json:"salary"`
	Title     string         `json:"title"`
	DeptName  sql.NullString `json:"dept_name"`
	IsManager int64          `json:"is_manager"`
}

// Get employees by title with salary and department info
func (q *Queries) GetEmployeesByTitleWithDetails(ctx context.Context, arg GetEmployeesByTitleWithDetailsParams) ([]GetEmployeesByTitleWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeesByTitleWithDetails,
		arg.ValidFrom,
		arg.ValidTo,
		arg.ValidFrom_2,
		arg.ValidTo_2,
		arg.ValidFrom_3,
		arg.ValidTo_3,
		arg.ValidFrom_4,
		arg.ValidTo_4,
		arg.Title,
		arg.ValidFrom_5,
		arg.ValidTo_5,
		arg.ValidFrom_6,
		arg.ValidTo_6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeesByTitleWithDetailsRow
	for rows.Next() {
		var i GetEmployeesByTitleWithDetailsRow
		if err := rows.Scan(
			&i.EmpNo,
			&i.FirstName,
			&i.LastName,
			&i.Salary,
			&i.Title,
			&i.DeptName,
			&i.IsManager,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManagersWithDetails = `-- name: GetManagersWithDetails :many
SELECT 
  e.emp_no, e.first_name, e.last_name,
  s.salary,
  t.title,
  d.dept_no, d.dept_name,
  dm.valid_from as manager_since
FROM employees e
JOIN dept_manager dm ON e.emp_no = dm.emp_no
JOIN departments d ON dm.dept_no = d.dept_no
LEFT JOIN salaries s ON e.emp_no = s.emp_no
  AND s.valid_from <= ? AND s.valid_to > ?
LEFT JOIN titles t ON e.emp_no = t.emp_no
  AND t.valid_from <= ? AND t.valid_to > ?
WHERE e.valid_from <= ? AND e.valid_to > ?
  AND dm.valid_from <= ? AND dm.valid_to > ?
  AND d.valid_from <= ? AND d.valid_to > ?
ORDER BY d.dept_no
`

type GetManagersWithDetailsParams struct {
	ValidFrom   time.Time `json:"valid_from"`
	ValidTo     time.Time `json:"valid_to"`
	ValidFrom_2 time.Time `json:"valid_from_2"`
	ValidTo_2   time.Time `json:"valid_to_2"`
	ValidFrom_3 time.Time `json:"valid_from_3"`
	ValidTo_3   time.Time `json:"valid_to_3"`
	ValidFrom_4 time.Time `json:"valid_from_4"`
	ValidTo_4   time.Time `json:"valid_to_4"`
	ValidFrom_5 time.Time `json:"valid_from_5"`
	ValidTo_5   time.Time `json:"valid_to_5"`
}

type GetManagersWithDetailsRow struct {
	EmpNo        int64          `json:"emp_no"`
	FirstName    string         `json:"first_name"`
	LastName     string         `json:"last_name"`
	Salary       sql.NullInt64  `json:"salary"`
	Title        sql.NullString `json:"title"`
	DeptNo       string         `json:"dept_no"`
	DeptName     string         `json:"dept_name"`
	ManagerSince time.Time      `json:"manager_since"`
}

// Get managers with their department info and salary
func (q *Queries) GetManagersWithDetails(ctx context.Context, arg GetManagersWithDetailsParams) ([]GetManagersWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getManagersWithDetails,
		arg.ValidFrom,
		arg.ValidTo,
		arg.ValidFrom_2,
		arg.ValidTo_2,
		arg.ValidFrom_3,
		arg.ValidTo_3,
		arg.ValidFrom_4,
		arg.ValidTo_4,
		arg.ValidFrom_5,
		arg.ValidTo_5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetManagersWithDetailsRow
	for rows.Next() {
		var i GetManagersWithDetailsRow
		if err := rows.Scan(
			&i.EmpNo,
			&i.FirstName,
			&i.LastName,
			&i.Salary,
			&i.Title,
			&i.DeptNo,
			&i.DeptName,
			&i.ManagerSince,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertEmployeeUpdate = `-- name: InsertEmployeeUpdate :one
INSERT INTO employees (
  emp_no, birth_date, first_name, last_name, gender, hire_date, valid_from, valid_to
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING emp_no, birth_date, first_name, last_name, gender, hire_date, valid_from, valid_to, transaction_time
`

type InsertEmployeeUpdateParams struct {
	EmpNo     int64     `json:"emp_no"`
	BirthDate time.Time `json:"birth_date"`
	FirstName string    `json:"first_name"`
	LastName  string    `json:"last_name"`
	Gender    string    `json:"gender"`
	HireDate  time.Time `json:"hire_date"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Insert updated employee record (used after closing previous record)
func (q *Queries) InsertEmployeeUpdate(ctx context.Context, arg InsertEmployeeUpdateParams) (Employee, error) {
	row := q.db.QueryRowContext(ctx, insertEmployeeUpdate,
		arg.EmpNo,
		arg.BirthDate,
		arg.FirstName,
		arg.LastName,
		arg.Gender,
		arg.HireDate,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i Employee
	err := row.Scan(
		&i.EmpNo,
		&i.BirthDate,
		&i.FirstName,
		&i.LastName,
		&i.Gender,
		&i.HireDate,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const listEmployeesAsOfTransaction = `-- name: ListEmployeesAsOfTransaction :many
SELECT DISTINCT emp_no, birth_date, first_name, last_name, gender, hire_date, 
       valid_from, valid_to, transaction_time
FROM employees e1
WHERE e1.transaction_time <= ?
  AND e1.valid_from <= ?
  AND e1.valid_to > ?
  AND e1.transaction_time = (
    SELECT MAX(e2.transaction_time)
    FROM employees e2
    WHERE e2.emp_no = e1.emp_no
      AND e2.transaction_time <= ?
  )
ORDER BY emp_no
`

type ListEmployeesAsOfTransactionParams struct {
	TransactionTime   sql.NullTime `json:"transaction_time"`
	ValidFrom         time.Time    `json:"valid_from"`
	ValidTo           time.Time    `json:"valid_to"`
	TransactionTime_2 sql.NullTime `json:"transaction_time_2"`
}

// Get employees as they existed at a specific transaction time
func (q *Queries) ListEmployeesAsOfTransaction(ctx context.Context, arg ListEmployeesAsOfTransactionParams) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, listEmployeesAsOfTransaction,
		arg.TransactionTime,
		arg.ValidFrom,
		arg.ValidTo,
		arg.TransactionTime_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmpNo,
			&i.BirthDate,
			&i.FirstName,
			&i.LastName,
			&i.Gender,
			&i.HireDate,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployeesCurrent = `-- name: ListEmployeesCurrent :many
SELECT emp_no, birth_date, first_name, last_name, gender, hire_date, valid_from, valid_to, transaction_time FROM employees
WHERE valid_from <= ? 
  AND valid_to > ?
ORDER BY emp_no
`

type ListEmployeesCurrentParams struct {
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Get all current employees (as of specific valid time)
func (q *Queries) ListEmployeesCurrent(ctx context.Context, arg ListEmployeesCurrentParams) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, listEmployeesCurrent, arg.ValidFrom, arg.ValidTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmpNo,
			&i.BirthDate,
			&i.FirstName,
			&i.LastName,
			&i.Gender,
			&i.HireDate,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployeesWithCurrentDetails = `-- name: ListEmployeesWithCurrentDetails :many
SELECT 
  e.emp_no, e.first_name, e.last_name, e.birth_date, e.gender, e.hire_date,
  COALESCE(s.salary, 0) as salary,
  COALESCE(t.title, 'No Title') as title,
  COALESCE(d.dept_no, '') as dept_no,
  COALESCE(d.dept_name, 'No Department') as dept_name,
  CASE WHEN dm.emp_no IS NOT NULL THEN true ELSE false END as is_manager
FROM employees e
LEFT JOIN salaries s ON e.emp_no = s.emp_no
  AND s.valid_from <= ? AND s.valid_to > ?
LEFT JOIN titles t ON e.emp_no = t.emp_no
  AND t.valid_from <= ? AND t.valid_to > ?
LEFT JOIN dept_emp de ON e.emp_no = de.emp_no
  AND de.valid_from <= ? AND de.valid_to > ?
LEFT JOIN departments d ON de.dept_no = d.dept_no
  AND d.valid_from <= ? AND d.valid_to > ?
LEFT JOIN dept_manager dm ON e.emp_no = dm.emp_no
  AND dm.valid_from <= ? AND dm.valid_to > ?
WHERE e.valid_from <= ? AND e.valid_to > ?
ORDER BY e.emp_no
LIMIT ?
`

type ListEmployeesWithCurrentDetailsParams struct {
	ValidFrom   time.Time `json:"valid_from"`
	ValidTo     time.Time `json:"valid_to"`
	ValidFrom_2 time.Time `json:"valid_from_2"`
	ValidTo_2   time.Time `json:"valid_to_2"`
	ValidFrom_3 time.Time `json:"valid_from_3"`
	ValidTo_3   time.Time `json:"valid_to_3"`
	ValidFrom_4 time.Time `json:"valid_from_4"`
	ValidTo_4   time.Time `json:"valid_to_4"`
	ValidFrom_5 time.Time `json:"valid_from_5"`
	ValidTo_5   time.Time `json:"valid_to_5"`
	ValidFrom_6 time.Time `json:"valid_from_6"`
	ValidTo_6   time.Time `json:"valid_to_6"`
	Limit       int64     `json:"limit"`
}

type ListEmployeesWithCurrentDetailsRow struct {
	EmpNo     int64     `json:"emp_no"`
	FirstName string    `json:"first_name"`
	LastName  string    `json:"last_name"`
	BirthDate time.Time `json:"birth_date"`
	Gender    string    `json:"gender"`
	HireDate  time.Time `json:"hire_date"`
	Salary    int64     `json:"salary"`
	Title     string    `json:"title"`
	DeptNo    string    `json:"dept_no"`
	DeptName  string    `json:"dept_name"`
	IsManager int64     `json:"is_manager"`
}

// Get all employees with their current salary, title, and department
func (q *Queries) ListEmployeesWithCurrentDetails(ctx context.Context, arg ListEmployeesWithCurrentDetailsParams) ([]ListEmployeesWithCurrentDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, listEmployeesWithCurrentDetails,
		arg.ValidFrom,
		arg.ValidTo,
		arg.ValidFrom_2,
		arg.ValidTo_2,
		arg.ValidFrom_3,
		arg.ValidTo_3,
		arg.ValidFrom_4,
		arg.ValidTo_4,
		arg.ValidFrom_5,
		arg.ValidTo_5,
		arg.ValidFrom_6,
		arg.ValidTo_6,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEmployeesWithCurrentDetailsRow
	for rows.Next() {
		var i ListEmployeesWithCurrentDetailsRow
		if err := rows.Scan(
			&i.EmpNo,
			&i.FirstName,
			&i.LastName,
			&i.BirthDate,
			&i.Gender,
			&i.HireDate,
			&i.Salary,
			&i.Title,
			&i.DeptNo,
			&i.DeptName,
			&i.IsManager,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchEmployeesByName = `-- name: SearchEmployeesByName :many
SELECT emp_no, birth_date, first_name, last_name, gender, hire_date, valid_from, valid_to, transaction_time FROM employees
WHERE (first_name LIKE ? OR last_name LIKE ?)
  AND valid_from <= ?
  AND valid_to > ?
ORDER BY last_name, first_name
`

type SearchEmployeesByNameParams struct {
	FirstName string    `json:"first_name"`
	LastName  string    `json:"last_name"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Search employees by name (current versions only)
func (q *Queries) SearchEmployeesByName(ctx context.Context, arg SearchEmployeesByNameParams) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, searchEmployeesByName,
		arg.FirstName,
		arg.LastName,
		arg.ValidFrom,
		arg.ValidTo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmpNo,
			&i.BirthDate,
			&i.FirstName,
			&i.LastName,
			&i.Gender,
			&i.HireDate,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
