// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dept_emp.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const closeAllEmployeeAssignments = `-- name: CloseAllEmployeeAssignments :exec
UPDATE dept_emp 
SET valid_to = ?
WHERE emp_no = ?
  AND valid_to = '9999-12-31 23:59:59'
`

type CloseAllEmployeeAssignmentsParams struct {
	ValidTo time.Time `json:"valid_to"`
	EmpNo   int64     `json:"emp_no"`
}

// Close all current assignments for employee (used before new assignment)
func (q *Queries) CloseAllEmployeeAssignments(ctx context.Context, arg CloseAllEmployeeAssignmentsParams) error {
	_, err := q.db.ExecContext(ctx, closeAllEmployeeAssignments, arg.ValidTo, arg.EmpNo)
	return err
}

const closeDeptEmpValidPeriod = `-- name: CloseDeptEmpValidPeriod :exec
UPDATE dept_emp 
SET valid_to = ?
WHERE emp_no = ?
  AND dept_no = ?
  AND valid_to = '9999-12-31 23:59:59'
`

type CloseDeptEmpValidPeriodParams struct {
	ValidTo time.Time `json:"valid_to"`
	EmpNo   int64     `json:"emp_no"`
	DeptNo  string    `json:"dept_no"`
}

// Close current department assignment (used before transfer)
func (q *Queries) CloseDeptEmpValidPeriod(ctx context.Context, arg CloseDeptEmpValidPeriodParams) error {
	_, err := q.db.ExecContext(ctx, closeDeptEmpValidPeriod, arg.ValidTo, arg.EmpNo, arg.DeptNo)
	return err
}

const createDeptEmp = `-- name: CreateDeptEmp :one
INSERT INTO dept_emp (
  emp_no, dept_no, valid_from, valid_to
) VALUES (
  ?, ?, ?, ?
)
RETURNING emp_no, dept_no, valid_from, valid_to, transaction_time
`

type CreateDeptEmpParams struct {
	EmpNo     int64     `json:"emp_no"`
	DeptNo    string    `json:"dept_no"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Create new department assignment
func (q *Queries) CreateDeptEmp(ctx context.Context, arg CreateDeptEmpParams) (DeptEmp, error) {
	row := q.db.QueryRowContext(ctx, createDeptEmp,
		arg.EmpNo,
		arg.DeptNo,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i DeptEmp
	err := row.Scan(
		&i.EmpNo,
		&i.DeptNo,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const getDepartmentEmployeesCurrent = `-- name: GetDepartmentEmployeesCurrent :many
SELECT emp_no, dept_no, valid_from, valid_to, transaction_time FROM dept_emp
WHERE dept_no = ?
  AND valid_from <= ?
  AND valid_to > ?
ORDER BY emp_no
`

type GetDepartmentEmployeesCurrentParams struct {
	DeptNo    string    `json:"dept_no"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Get all employees in department (current assignments)
func (q *Queries) GetDepartmentEmployeesCurrent(ctx context.Context, arg GetDepartmentEmployeesCurrentParams) ([]DeptEmp, error) {
	rows, err := q.db.QueryContext(ctx, getDepartmentEmployeesCurrent, arg.DeptNo, arg.ValidFrom, arg.ValidTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeptEmp
	for rows.Next() {
		var i DeptEmp
		if err := rows.Scan(
			&i.EmpNo,
			&i.DeptNo,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDepartmentTransfers = `-- name: GetDepartmentTransfers :many
SELECT de1.emp_no, de1.dept_no as old_dept, de2.dept_no as new_dept,
       de1.valid_to as transfer_date
FROM dept_emp de1
JOIN dept_emp de2 ON de1.emp_no = de2.emp_no
WHERE de1.valid_to BETWEEN ? AND ?
  AND de2.valid_from = de1.valid_to
  AND de1.dept_no != de2.dept_no
ORDER BY de1.valid_to, de1.emp_no
`

type GetDepartmentTransfersParams struct {
	ValidTo   time.Time `json:"valid_to"`
	ValidTo_2 time.Time `json:"valid_to_2"`
	ValidTo_3 time.Time `json:"valid_to_3"`
	ValidTo_4 time.Time `json:"valid_to_4"`
}

type GetDepartmentTransfersRow struct {
	EmpNo        int64     `json:"emp_no"`
	OldDept      string    `json:"old_dept"`
	NewDept      string    `json:"new_dept"`
	TransferDate time.Time `json:"transfer_date"`
}

// Get employees who changed departments in date range
func (q *Queries) GetDepartmentTransfers(ctx context.Context, arg GetDepartmentTransfersParams) ([]GetDepartmentTransfersRow, error) {
	rows, err := q.db.QueryContext(ctx, getDepartmentTransfers,
		arg.ValidTo,
		arg.ValidTo_2,
		arg.ValidTo_3,
		arg.ValidTo_4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDepartmentTransfersRow
	for rows.Next() {
		var i GetDepartmentTransfersRow
		if err := rows.Scan(
			&i.EmpNo,
			&i.OldDept,
			&i.NewDept,
			&i.TransferDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeDepartmentAsOfTransaction = `-- name: GetEmployeeDepartmentAsOfTransaction :one
SELECT emp_no, dept_no, valid_from, valid_to, transaction_time FROM dept_emp
WHERE emp_no = ?
  AND transaction_time <= ?
  AND valid_from <= ?
  AND valid_to > ?
ORDER BY transaction_time DESC
LIMIT 1
`

type GetEmployeeDepartmentAsOfTransactionParams struct {
	EmpNo           int64        `json:"emp_no"`
	TransactionTime sql.NullTime `json:"transaction_time"`
	ValidFrom       time.Time    `json:"valid_from"`
	ValidTo         time.Time    `json:"valid_to"`
}

// Get department assignment as it was known at specific transaction time
func (q *Queries) GetEmployeeDepartmentAsOfTransaction(ctx context.Context, arg GetEmployeeDepartmentAsOfTransactionParams) (DeptEmp, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeDepartmentAsOfTransaction,
		arg.EmpNo,
		arg.TransactionTime,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i DeptEmp
	err := row.Scan(
		&i.EmpNo,
		&i.DeptNo,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const getEmployeeDepartmentCurrent = `-- name: GetEmployeeDepartmentCurrent :one

SELECT emp_no, dept_no, valid_from, valid_to, transaction_time FROM dept_emp
WHERE emp_no = ? 
  AND valid_from <= ? 
  AND valid_to > ?
ORDER BY transaction_time DESC
LIMIT 1
`

type GetEmployeeDepartmentCurrentParams struct {
	EmpNo     int64     `json:"emp_no"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Bitemporal Department-Employee Assignment Queries
// Get current department assignment for employee
func (q *Queries) GetEmployeeDepartmentCurrent(ctx context.Context, arg GetEmployeeDepartmentCurrentParams) (DeptEmp, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeDepartmentCurrent, arg.EmpNo, arg.ValidFrom, arg.ValidTo)
	var i DeptEmp
	err := row.Scan(
		&i.EmpNo,
		&i.DeptNo,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const getEmployeeDepartmentHistory = `-- name: GetEmployeeDepartmentHistory :many
SELECT emp_no, dept_no, valid_from, valid_to, transaction_time FROM dept_emp
WHERE emp_no = ?
ORDER BY valid_from, transaction_time
`

// Get complete history of department assignments for employee
func (q *Queries) GetEmployeeDepartmentHistory(ctx context.Context, empNo int64) ([]DeptEmp, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeDepartmentHistory, empNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeptEmp
	for rows.Next() {
		var i DeptEmp
		if err := rows.Scan(
			&i.EmpNo,
			&i.DeptNo,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDeptEmpUpdate = `-- name: InsertDeptEmpUpdate :one
INSERT INTO dept_emp (
  emp_no, dept_no, valid_from, valid_to
) VALUES (
  ?, ?, ?, ?
)
RETURNING emp_no, dept_no, valid_from, valid_to, transaction_time
`

type InsertDeptEmpUpdateParams struct {
	EmpNo     int64     `json:"emp_no"`
	DeptNo    string    `json:"dept_no"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Insert updated department assignment
func (q *Queries) InsertDeptEmpUpdate(ctx context.Context, arg InsertDeptEmpUpdateParams) (DeptEmp, error) {
	row := q.db.QueryRowContext(ctx, insertDeptEmpUpdate,
		arg.EmpNo,
		arg.DeptNo,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i DeptEmp
	err := row.Scan(
		&i.EmpNo,
		&i.DeptNo,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const listDeptEmpAsOfTransaction = `-- name: ListDeptEmpAsOfTransaction :many
SELECT DISTINCT emp_no, dept_no, valid_from, valid_to, transaction_time
FROM dept_emp de1
WHERE de1.transaction_time <= ?
  AND de1.valid_from <= ?
  AND de1.valid_to > ?
  AND de1.transaction_time = (
    SELECT MAX(de2.transaction_time)
    FROM dept_emp de2
    WHERE de2.emp_no = de1.emp_no
      AND de2.dept_no = de1.dept_no
      AND de2.transaction_time <= ?
  )
ORDER BY emp_no, dept_no
`

type ListDeptEmpAsOfTransactionParams struct {
	TransactionTime   sql.NullTime `json:"transaction_time"`
	ValidFrom         time.Time    `json:"valid_from"`
	ValidTo           time.Time    `json:"valid_to"`
	TransactionTime_2 sql.NullTime `json:"transaction_time_2"`
}

// Get department assignments as they existed at specific transaction time
func (q *Queries) ListDeptEmpAsOfTransaction(ctx context.Context, arg ListDeptEmpAsOfTransactionParams) ([]DeptEmp, error) {
	rows, err := q.db.QueryContext(ctx, listDeptEmpAsOfTransaction,
		arg.TransactionTime,
		arg.ValidFrom,
		arg.ValidTo,
		arg.TransactionTime_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeptEmp
	for rows.Next() {
		var i DeptEmp
		if err := rows.Scan(
			&i.EmpNo,
			&i.DeptNo,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transferEmployee = `-- name: TransferEmployee :exec
UPDATE dept_emp 
SET valid_to = ?
WHERE emp_no = ?
  AND valid_to = '9999-12-31 23:59:59'
`

type TransferEmployeeParams struct {
	ValidTo time.Time `json:"valid_to"`
	EmpNo   int64     `json:"emp_no"`
}

// Transfer employee to new department (close old, create new)
func (q *Queries) TransferEmployee(ctx context.Context, arg TransferEmployeeParams) error {
	_, err := q.db.ExecContext(ctx, transferEmployee, arg.ValidTo, arg.EmpNo)
	return err
}
