// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: salaries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const closeEmployeeSalaryValidPeriod = `-- name: CloseEmployeeSalaryValidPeriod :exec
UPDATE salaries 
SET valid_to = ?
WHERE emp_no = ?
  AND valid_to = '9999-12-31 23:59:59'
`

type CloseEmployeeSalaryValidPeriodParams struct {
	ValidTo time.Time `json:"valid_to"`
	EmpNo   int64     `json:"emp_no"`
}

// Close current salary (used before salary change)
func (q *Queries) CloseEmployeeSalaryValidPeriod(ctx context.Context, arg CloseEmployeeSalaryValidPeriodParams) error {
	_, err := q.db.ExecContext(ctx, closeEmployeeSalaryValidPeriod, arg.ValidTo, arg.EmpNo)
	return err
}

const createSalary = `-- name: CreateSalary :one
INSERT INTO salaries (
  emp_no, salary, valid_from, valid_to
) VALUES (
  ?, ?, ?, ?
)
RETURNING emp_no, salary, valid_from, valid_to, transaction_time
`

type CreateSalaryParams struct {
	EmpNo     int64     `json:"emp_no"`
	Salary    int64     `json:"salary"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Create new salary record
func (q *Queries) CreateSalary(ctx context.Context, arg CreateSalaryParams) (Salary, error) {
	row := q.db.QueryRowContext(ctx, createSalary,
		arg.EmpNo,
		arg.Salary,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i Salary
	err := row.Scan(
		&i.EmpNo,
		&i.Salary,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const getEmployeeSalaryAsOfTransaction = `-- name: GetEmployeeSalaryAsOfTransaction :one
SELECT emp_no, salary, valid_from, valid_to, transaction_time FROM salaries
WHERE emp_no = ?
  AND transaction_time <= ?
  AND valid_from <= ?
  AND valid_to > ?
ORDER BY transaction_time DESC
LIMIT 1
`

type GetEmployeeSalaryAsOfTransactionParams struct {
	EmpNo           int64        `json:"emp_no"`
	TransactionTime sql.NullTime `json:"transaction_time"`
	ValidFrom       time.Time    `json:"valid_from"`
	ValidTo         time.Time    `json:"valid_to"`
}

// Get employee salary as it was known at specific transaction time
func (q *Queries) GetEmployeeSalaryAsOfTransaction(ctx context.Context, arg GetEmployeeSalaryAsOfTransactionParams) (Salary, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeSalaryAsOfTransaction,
		arg.EmpNo,
		arg.TransactionTime,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i Salary
	err := row.Scan(
		&i.EmpNo,
		&i.Salary,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const getEmployeeSalaryCurrent = `-- name: GetEmployeeSalaryCurrent :one

SELECT emp_no, salary, valid_from, valid_to, transaction_time FROM salaries
WHERE emp_no = ? 
  AND valid_from <= ? 
  AND valid_to > ?
ORDER BY transaction_time DESC
LIMIT 1
`

type GetEmployeeSalaryCurrentParams struct {
	EmpNo     int64     `json:"emp_no"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Bitemporal Employee Salary Queries
// Get current salary for employee
func (q *Queries) GetEmployeeSalaryCurrent(ctx context.Context, arg GetEmployeeSalaryCurrentParams) (Salary, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeSalaryCurrent, arg.EmpNo, arg.ValidFrom, arg.ValidTo)
	var i Salary
	err := row.Scan(
		&i.EmpNo,
		&i.Salary,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const getEmployeeSalaryHistory = `-- name: GetEmployeeSalaryHistory :many
SELECT emp_no, salary, valid_from, valid_to, transaction_time FROM salaries
WHERE emp_no = ?
ORDER BY valid_from, transaction_time
`

// Get complete salary history for employee
func (q *Queries) GetEmployeeSalaryHistory(ctx context.Context, empNo int64) ([]Salary, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeSalaryHistory, empNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Salary
	for rows.Next() {
		var i Salary
		if err := rows.Scan(
			&i.EmpNo,
			&i.Salary,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalaryChanges = `-- name: GetSalaryChanges :many
SELECT s1.emp_no, s1.salary as old_salary, s2.salary as new_salary,
       s1.valid_to as change_date,
       ROUND(((s2.salary - s1.salary) * 100.0 / s1.salary), 2) as percent_change
FROM salaries s1
JOIN salaries s2 ON s1.emp_no = s2.emp_no
WHERE s1.valid_to BETWEEN ? AND ?
  AND s2.valid_from = s1.valid_to
  AND s1.salary != s2.salary
ORDER BY s1.valid_to, s1.emp_no
`

type GetSalaryChangesParams struct {
	ValidTo   time.Time `json:"valid_to"`
	ValidTo_2 time.Time `json:"valid_to_2"`
	ValidTo_3 time.Time `json:"valid_to_3"`
	ValidTo_4 time.Time `json:"valid_to_4"`
}

type GetSalaryChangesRow struct {
	EmpNo         int64     `json:"emp_no"`
	OldSalary     int64     `json:"old_salary"`
	NewSalary     int64     `json:"new_salary"`
	ChangeDate    time.Time `json:"change_date"`
	PercentChange float64   `json:"percent_change"`
}

// Get salary changes in date range
func (q *Queries) GetSalaryChanges(ctx context.Context, arg GetSalaryChangesParams) ([]GetSalaryChangesRow, error) {
	rows, err := q.db.QueryContext(ctx, getSalaryChanges,
		arg.ValidTo,
		arg.ValidTo_2,
		arg.ValidTo_3,
		arg.ValidTo_4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSalaryChangesRow
	for rows.Next() {
		var i GetSalaryChangesRow
		if err := rows.Scan(
			&i.EmpNo,
			&i.OldSalary,
			&i.NewSalary,
			&i.ChangeDate,
			&i.PercentChange,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalaryRaisesAbovePercent = `-- name: GetSalaryRaisesAbovePercent :many
SELECT s1.emp_no, e.first_name, e.last_name,
       s1.salary as old_salary, s2.salary as new_salary,
       s2.valid_from as raise_date,
       ROUND(((s2.salary - s1.salary) * 100.0 / s1.salary), 2) as percent_increase
FROM salaries s1
JOIN salaries s2 ON s1.emp_no = s2.emp_no
JOIN employees e ON s1.emp_no = e.emp_no
WHERE s2.valid_from BETWEEN ? AND ?
  AND s1.valid_to = s2.valid_from
  AND s2.salary > s1.salary
  AND ((s2.salary - s1.salary) * 100.0 / s1.salary) >= ?
  AND e.valid_from <= s2.valid_from
  AND e.valid_to > s2.valid_from
ORDER BY percent_increase DESC
`

type GetSalaryRaisesAbovePercentParams struct {
	ValidFrom   time.Time `json:"valid_from"`
	ValidFrom_2 time.Time `json:"valid_from_2"`
	ValidFrom_3 time.Time `json:"valid_from_3"`
	ValidFrom_4 time.Time `json:"valid_from_4"`
	ValidFrom_5 time.Time `json:"valid_from_5"`
	ValidFrom_6 time.Time `json:"valid_from_6"`
	Salary      int64     `json:"salary"`
}

type GetSalaryRaisesAbovePercentRow struct {
	EmpNo           int64     `json:"emp_no"`
	FirstName       string    `json:"first_name"`
	LastName        string    `json:"last_name"`
	OldSalary       int64     `json:"old_salary"`
	NewSalary       int64     `json:"new_salary"`
	RaiseDate       time.Time `json:"raise_date"`
	PercentIncrease float64   `json:"percent_increase"`
}

// Get employees with salary raises above percentage
func (q *Queries) GetSalaryRaisesAbovePercent(ctx context.Context, arg GetSalaryRaisesAbovePercentParams) ([]GetSalaryRaisesAbovePercentRow, error) {
	rows, err := q.db.QueryContext(ctx, getSalaryRaisesAbovePercent,
		arg.ValidFrom,
		arg.ValidFrom_2,
		arg.ValidFrom_3,
		arg.ValidFrom_4,
		arg.ValidFrom_5,
		arg.ValidFrom_6,
		arg.Salary,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSalaryRaisesAbovePercentRow
	for rows.Next() {
		var i GetSalaryRaisesAbovePercentRow
		if err := rows.Scan(
			&i.EmpNo,
			&i.FirstName,
			&i.LastName,
			&i.OldSalary,
			&i.NewSalary,
			&i.RaiseDate,
			&i.PercentIncrease,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalaryStatistics = `-- name: GetSalaryStatistics :one
SELECT 
  COUNT(*) as employee_count,
  MIN(salary) as min_salary,
  MAX(salary) as max_salary,
  ROUND(AVG(salary), 2) as avg_salary
FROM salaries
WHERE valid_from <= ?
  AND valid_to > ?
`

type GetSalaryStatisticsParams struct {
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

type GetSalaryStatisticsRow struct {
	EmployeeCount int64       `json:"employee_count"`
	MinSalary     interface{} `json:"min_salary"`
	MaxSalary     interface{} `json:"max_salary"`
	AvgSalary     float64     `json:"avg_salary"`
}

// Get salary statistics for date range
func (q *Queries) GetSalaryStatistics(ctx context.Context, arg GetSalaryStatisticsParams) (GetSalaryStatisticsRow, error) {
	row := q.db.QueryRowContext(ctx, getSalaryStatistics, arg.ValidFrom, arg.ValidTo)
	var i GetSalaryStatisticsRow
	err := row.Scan(
		&i.EmployeeCount,
		&i.MinSalary,
		&i.MaxSalary,
		&i.AvgSalary,
	)
	return i, err
}

const getTopEarners = `-- name: GetTopEarners :many
SELECT s.emp_no, e.first_name, e.last_name, s.salary
FROM salaries s
JOIN employees e ON s.emp_no = e.emp_no
WHERE s.valid_from <= ?
  AND s.valid_to > ?
  AND e.valid_from <= ?
  AND e.valid_to > ?
ORDER BY s.salary DESC
LIMIT ?
`

type GetTopEarnersParams struct {
	ValidFrom   time.Time `json:"valid_from"`
	ValidTo     time.Time `json:"valid_to"`
	ValidFrom_2 time.Time `json:"valid_from_2"`
	ValidTo_2   time.Time `json:"valid_to_2"`
	Limit       int64     `json:"limit"`
}

type GetTopEarnersRow struct {
	EmpNo     int64  `json:"emp_no"`
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Salary    int64  `json:"salary"`
}

// Get top earners (current)
func (q *Queries) GetTopEarners(ctx context.Context, arg GetTopEarnersParams) ([]GetTopEarnersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopEarners,
		arg.ValidFrom,
		arg.ValidTo,
		arg.ValidFrom_2,
		arg.ValidTo_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopEarnersRow
	for rows.Next() {
		var i GetTopEarnersRow
		if err := rows.Scan(
			&i.EmpNo,
			&i.FirstName,
			&i.LastName,
			&i.Salary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSalaryUpdate = `-- name: InsertSalaryUpdate :one
INSERT INTO salaries (
  emp_no, salary, valid_from, valid_to
) VALUES (
  ?, ?, ?, ?
)
RETURNING emp_no, salary, valid_from, valid_to, transaction_time
`

type InsertSalaryUpdateParams struct {
	EmpNo     int64     `json:"emp_no"`
	Salary    int64     `json:"salary"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Insert updated salary (raise/cut)
func (q *Queries) InsertSalaryUpdate(ctx context.Context, arg InsertSalaryUpdateParams) (Salary, error) {
	row := q.db.QueryRowContext(ctx, insertSalaryUpdate,
		arg.EmpNo,
		arg.Salary,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i Salary
	err := row.Scan(
		&i.EmpNo,
		&i.Salary,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const listCurrentSalariesWithEmployees = `-- name: ListCurrentSalariesWithEmployees :many
SELECT s.emp_no, s.salary, s.valid_from, s.valid_to, s.transaction_time, e.first_name, e.last_name 
FROM salaries s
JOIN employees e ON s.emp_no = e.emp_no
WHERE s.valid_from <= ? 
  AND s.valid_to > ?
  AND e.valid_from <= ?
  AND e.valid_to > ?
ORDER BY s.salary DESC
`

type ListCurrentSalariesWithEmployeesParams struct {
	ValidFrom   time.Time `json:"valid_from"`
	ValidTo     time.Time `json:"valid_to"`
	ValidFrom_2 time.Time `json:"valid_from_2"`
	ValidTo_2   time.Time `json:"valid_to_2"`
}

type ListCurrentSalariesWithEmployeesRow struct {
	EmpNo           int64        `json:"emp_no"`
	Salary          int64        `json:"salary"`
	ValidFrom       time.Time    `json:"valid_from"`
	ValidTo         time.Time    `json:"valid_to"`
	TransactionTime sql.NullTime `json:"transaction_time"`
	FirstName       string       `json:"first_name"`
	LastName        string       `json:"last_name"`
}

// Get all current salaries with employee info
func (q *Queries) ListCurrentSalariesWithEmployees(ctx context.Context, arg ListCurrentSalariesWithEmployeesParams) ([]ListCurrentSalariesWithEmployeesRow, error) {
	rows, err := q.db.QueryContext(ctx, listCurrentSalariesWithEmployees,
		arg.ValidFrom,
		arg.ValidTo,
		arg.ValidFrom_2,
		arg.ValidTo_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCurrentSalariesWithEmployeesRow
	for rows.Next() {
		var i ListCurrentSalariesWithEmployeesRow
		if err := rows.Scan(
			&i.EmpNo,
			&i.Salary,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSalariesAsOfTransaction = `-- name: ListSalariesAsOfTransaction :many
SELECT DISTINCT emp_no, salary, valid_from, valid_to, transaction_time
FROM salaries s1
WHERE s1.transaction_time <= ?
  AND s1.valid_from <= ?
  AND s1.valid_to > ?
  AND s1.transaction_time = (
    SELECT MAX(s2.transaction_time)
    FROM salaries s2
    WHERE s2.emp_no = s1.emp_no
      AND s2.transaction_time <= ?
  )
ORDER BY emp_no
`

type ListSalariesAsOfTransactionParams struct {
	TransactionTime   sql.NullTime `json:"transaction_time"`
	ValidFrom         time.Time    `json:"valid_from"`
	ValidTo           time.Time    `json:"valid_to"`
	TransactionTime_2 sql.NullTime `json:"transaction_time_2"`
}

// Get salaries as they existed at specific transaction time
func (q *Queries) ListSalariesAsOfTransaction(ctx context.Context, arg ListSalariesAsOfTransactionParams) ([]Salary, error) {
	rows, err := q.db.QueryContext(ctx, listSalariesAsOfTransaction,
		arg.TransactionTime,
		arg.ValidFrom,
		arg.ValidTo,
		arg.TransactionTime_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Salary
	for rows.Next() {
		var i Salary
		if err := rows.Scan(
			&i.EmpNo,
			&i.Salary,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
