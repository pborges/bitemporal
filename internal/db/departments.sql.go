// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: departments.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const closeDepartmentValidPeriod = `-- name: CloseDepartmentValidPeriod :exec
UPDATE departments 
SET valid_to = ?
WHERE dept_no = ?
  AND valid_to = '9999-12-31 23:59:59'
`

type CloseDepartmentValidPeriodParams struct {
	ValidTo time.Time `json:"valid_to"`
	DeptNo  string    `json:"dept_no"`
}

// Close current valid period for department (used before update)
func (q *Queries) CloseDepartmentValidPeriod(ctx context.Context, arg CloseDepartmentValidPeriodParams) error {
	_, err := q.db.ExecContext(ctx, closeDepartmentValidPeriod, arg.ValidTo, arg.DeptNo)
	return err
}

const createDepartment = `-- name: CreateDepartment :one
INSERT INTO departments (
  dept_no, dept_name, valid_from, valid_to
) VALUES (
  ?, ?, ?, ?
)
RETURNING dept_no, dept_name, valid_from, valid_to, transaction_time
`

type CreateDepartmentParams struct {
	DeptNo    string    `json:"dept_no"`
	DeptName  string    `json:"dept_name"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Create new department
func (q *Queries) CreateDepartment(ctx context.Context, arg CreateDepartmentParams) (Department, error) {
	row := q.db.QueryRowContext(ctx, createDepartment,
		arg.DeptNo,
		arg.DeptName,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i Department
	err := row.Scan(
		&i.DeptNo,
		&i.DeptName,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const deleteDepartment = `-- name: DeleteDepartment :exec
UPDATE departments 
SET valid_to = ?
WHERE dept_no = ?
  AND valid_to = '9999-12-31 23:59:59'
`

type DeleteDepartmentParams struct {
	ValidTo time.Time `json:"valid_to"`
	DeptNo  string    `json:"dept_no"`
}

// Logical delete (close valid period)
func (q *Queries) DeleteDepartment(ctx context.Context, arg DeleteDepartmentParams) error {
	_, err := q.db.ExecContext(ctx, deleteDepartment, arg.ValidTo, arg.DeptNo)
	return err
}

const getDepartmentAsOfTransaction = `-- name: GetDepartmentAsOfTransaction :one
SELECT dept_no, dept_name, valid_from, valid_to, transaction_time FROM departments
WHERE dept_no = ?
  AND transaction_time <= ?
  AND valid_from <= ?
  AND valid_to > ?
ORDER BY transaction_time DESC
LIMIT 1
`

type GetDepartmentAsOfTransactionParams struct {
	DeptNo          string       `json:"dept_no"`
	TransactionTime sql.NullTime `json:"transaction_time"`
	ValidFrom       time.Time    `json:"valid_from"`
	ValidTo         time.Time    `json:"valid_to"`
}

// Get department as it was known at a specific transaction time (time travel)
func (q *Queries) GetDepartmentAsOfTransaction(ctx context.Context, arg GetDepartmentAsOfTransactionParams) (Department, error) {
	row := q.db.QueryRowContext(ctx, getDepartmentAsOfTransaction,
		arg.DeptNo,
		arg.TransactionTime,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i Department
	err := row.Scan(
		&i.DeptNo,
		&i.DeptName,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const getDepartmentCurrent = `-- name: GetDepartmentCurrent :one

SELECT dept_no, dept_name, valid_from, valid_to, transaction_time FROM departments
WHERE dept_no = ? 
  AND valid_from <= ? 
  AND valid_to > ?
ORDER BY transaction_time DESC
LIMIT 1
`

type GetDepartmentCurrentParams struct {
	DeptNo    string    `json:"dept_no"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Bitemporal Department Queries
// Get current version of department (as of specific valid time)
func (q *Queries) GetDepartmentCurrent(ctx context.Context, arg GetDepartmentCurrentParams) (Department, error) {
	row := q.db.QueryRowContext(ctx, getDepartmentCurrent, arg.DeptNo, arg.ValidFrom, arg.ValidTo)
	var i Department
	err := row.Scan(
		&i.DeptNo,
		&i.DeptName,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const getDepartmentHistory = `-- name: GetDepartmentHistory :many
SELECT dept_no, dept_name, valid_from, valid_to, transaction_time FROM departments
WHERE dept_no = ?
ORDER BY valid_from, transaction_time
`

// Get complete history of department changes
func (q *Queries) GetDepartmentHistory(ctx context.Context, deptNo string) ([]Department, error) {
	rows, err := q.db.QueryContext(ctx, getDepartmentHistory, deptNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Department
	for rows.Next() {
		var i Department
		if err := rows.Scan(
			&i.DeptNo,
			&i.DeptName,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDepartmentUpdate = `-- name: InsertDepartmentUpdate :one
INSERT INTO departments (
  dept_no, dept_name, valid_from, valid_to
) VALUES (
  ?, ?, ?, ?
)
RETURNING dept_no, dept_name, valid_from, valid_to, transaction_time
`

type InsertDepartmentUpdateParams struct {
	DeptNo    string    `json:"dept_no"`
	DeptName  string    `json:"dept_name"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Insert updated department record
func (q *Queries) InsertDepartmentUpdate(ctx context.Context, arg InsertDepartmentUpdateParams) (Department, error) {
	row := q.db.QueryRowContext(ctx, insertDepartmentUpdate,
		arg.DeptNo,
		arg.DeptName,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i Department
	err := row.Scan(
		&i.DeptNo,
		&i.DeptName,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const listDepartmentsAsOfTransaction = `-- name: ListDepartmentsAsOfTransaction :many
SELECT DISTINCT dept_no, dept_name, valid_from, valid_to, transaction_time
FROM departments d1
WHERE d1.transaction_time <= ?
  AND d1.valid_from <= ?
  AND d1.valid_to > ?
  AND d1.transaction_time = (
    SELECT MAX(d2.transaction_time)
    FROM departments d2
    WHERE d2.dept_no = d1.dept_no
      AND d2.transaction_time <= ?
  )
ORDER BY dept_no
`

type ListDepartmentsAsOfTransactionParams struct {
	TransactionTime   sql.NullTime `json:"transaction_time"`
	ValidFrom         time.Time    `json:"valid_from"`
	ValidTo           time.Time    `json:"valid_to"`
	TransactionTime_2 sql.NullTime `json:"transaction_time_2"`
}

// Get departments as they existed at a specific transaction time
func (q *Queries) ListDepartmentsAsOfTransaction(ctx context.Context, arg ListDepartmentsAsOfTransactionParams) ([]Department, error) {
	rows, err := q.db.QueryContext(ctx, listDepartmentsAsOfTransaction,
		arg.TransactionTime,
		arg.ValidFrom,
		arg.ValidTo,
		arg.TransactionTime_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Department
	for rows.Next() {
		var i Department
		if err := rows.Scan(
			&i.DeptNo,
			&i.DeptName,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDepartmentsCurrent = `-- name: ListDepartmentsCurrent :many
SELECT dept_no, dept_name, valid_from, valid_to, transaction_time FROM departments
WHERE valid_from <= ? 
  AND valid_to > ?
ORDER BY dept_no
`

type ListDepartmentsCurrentParams struct {
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Get all current departments (as of specific valid time)
func (q *Queries) ListDepartmentsCurrent(ctx context.Context, arg ListDepartmentsCurrentParams) ([]Department, error) {
	rows, err := q.db.QueryContext(ctx, listDepartmentsCurrent, arg.ValidFrom, arg.ValidTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Department
	for rows.Next() {
		var i Department
		if err := rows.Scan(
			&i.DeptNo,
			&i.DeptName,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDepartmentsByName = `-- name: SearchDepartmentsByName :many
SELECT dept_no, dept_name, valid_from, valid_to, transaction_time FROM departments
WHERE dept_name LIKE ?
  AND valid_from <= ?
  AND valid_to > ?
ORDER BY dept_name
`

type SearchDepartmentsByNameParams struct {
	DeptName  string    `json:"dept_name"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Search departments by name
func (q *Queries) SearchDepartmentsByName(ctx context.Context, arg SearchDepartmentsByNameParams) ([]Department, error) {
	rows, err := q.db.QueryContext(ctx, searchDepartmentsByName, arg.DeptName, arg.ValidFrom, arg.ValidTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Department
	for rows.Next() {
		var i Department
		if err := rows.Scan(
			&i.DeptNo,
			&i.DeptName,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
