// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: bitemporal.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const getDepartmentOrgChart = `-- name: GetDepartmentOrgChart :many
SELECT 
  d.dept_no, d.dept_name,
  e.emp_no as manager_emp_no, e.first_name as manager_first_name, e.last_name as manager_last_name,
  COUNT(DISTINCT de.emp_no) as employee_count,
  ROUND(AVG(s.salary), 2) as avg_salary
FROM departments d
LEFT JOIN dept_manager dm ON d.dept_no = dm.dept_no
  AND dm.valid_from <= ? AND dm.valid_to > ?
LEFT JOIN employees e ON dm.emp_no = e.emp_no
  AND e.valid_from <= ? AND e.valid_to > ?
LEFT JOIN dept_emp de ON d.dept_no = de.dept_no
  AND de.valid_from <= ? AND de.valid_to > ?
LEFT JOIN salaries s ON de.emp_no = s.emp_no
  AND s.valid_from <= ? AND s.valid_to > ?
WHERE d.valid_from <= ? AND d.valid_to > ?
GROUP BY d.dept_no, d.dept_name, e.emp_no, e.first_name, e.last_name
ORDER BY d.dept_no
`

type GetDepartmentOrgChartParams struct {
	ValidFrom   time.Time `json:"valid_from"`
	ValidTo     time.Time `json:"valid_to"`
	ValidFrom_2 time.Time `json:"valid_from_2"`
	ValidTo_2   time.Time `json:"valid_to_2"`
	ValidFrom_3 time.Time `json:"valid_from_3"`
	ValidTo_3   time.Time `json:"valid_to_3"`
	ValidFrom_4 time.Time `json:"valid_from_4"`
	ValidTo_4   time.Time `json:"valid_to_4"`
	ValidFrom_5 time.Time `json:"valid_from_5"`
	ValidTo_5   time.Time `json:"valid_to_5"`
}

type GetDepartmentOrgChartRow struct {
	DeptNo           string         `json:"dept_no"`
	DeptName         string         `json:"dept_name"`
	ManagerEmpNo     sql.NullInt64  `json:"manager_emp_no"`
	ManagerFirstName sql.NullString `json:"manager_first_name"`
	ManagerLastName  sql.NullString `json:"manager_last_name"`
	EmployeeCount    int64          `json:"employee_count"`
	AvgSalary        float64        `json:"avg_salary"`
}

// Get department organization chart (current managers and employee count)
func (q *Queries) GetDepartmentOrgChart(ctx context.Context, arg GetDepartmentOrgChartParams) ([]GetDepartmentOrgChartRow, error) {
	rows, err := q.db.QueryContext(ctx, getDepartmentOrgChart,
		arg.ValidFrom,
		arg.ValidTo,
		arg.ValidFrom_2,
		arg.ValidTo_2,
		arg.ValidFrom_3,
		arg.ValidTo_3,
		arg.ValidFrom_4,
		arg.ValidTo_4,
		arg.ValidFrom_5,
		arg.ValidTo_5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDepartmentOrgChartRow
	for rows.Next() {
		var i GetDepartmentOrgChartRow
		if err := rows.Scan(
			&i.DeptNo,
			&i.DeptName,
			&i.ManagerEmpNo,
			&i.ManagerFirstName,
			&i.ManagerLastName,
			&i.EmployeeCount,
			&i.AvgSalary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDepartmentPayroll = `-- name: GetDepartmentPayroll :many
SELECT 
  e.emp_no, e.first_name, e.last_name,
  t.title,
  s.salary,
  CASE WHEN dm.emp_no IS NOT NULL THEN 'Manager' ELSE 'Employee' END as role
FROM employees e
JOIN dept_emp de ON e.emp_no = de.emp_no
JOIN departments d ON de.dept_no = d.dept_no
JOIN titles t ON e.emp_no = t.emp_no
JOIN salaries s ON e.emp_no = s.emp_no
LEFT JOIN dept_manager dm ON e.emp_no = dm.emp_no AND de.dept_no = dm.dept_no
WHERE d.dept_no = ?
  AND e.valid_from <= ? AND e.valid_to > ?
  AND de.valid_from <= ? AND de.valid_to > ?
  AND t.valid_from <= ? AND t.valid_to > ?
  AND s.valid_from <= ? AND s.valid_to > ?
  AND d.valid_from <= ? AND d.valid_to > ?
  AND (dm.emp_no IS NULL OR (dm.valid_from <= ? AND dm.valid_to > ?))
ORDER BY s.salary DESC
`

type GetDepartmentPayrollParams struct {
	DeptNo      string    `json:"dept_no"`
	ValidFrom   time.Time `json:"valid_from"`
	ValidTo     time.Time `json:"valid_to"`
	ValidFrom_2 time.Time `json:"valid_from_2"`
	ValidTo_2   time.Time `json:"valid_to_2"`
	ValidFrom_3 time.Time `json:"valid_from_3"`
	ValidTo_3   time.Time `json:"valid_to_3"`
	ValidFrom_4 time.Time `json:"valid_from_4"`
	ValidTo_4   time.Time `json:"valid_to_4"`
	ValidFrom_5 time.Time `json:"valid_from_5"`
	ValidTo_5   time.Time `json:"valid_to_5"`
	ValidFrom_6 time.Time `json:"valid_from_6"`
	ValidTo_6   time.Time `json:"valid_to_6"`
}

type GetDepartmentPayrollRow struct {
	EmpNo     int64  `json:"emp_no"`
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Title     string `json:"title"`
	Salary    int64  `json:"salary"`
	Role      string `json:"role"`
}

// Get payroll summary for department at specific date
func (q *Queries) GetDepartmentPayroll(ctx context.Context, arg GetDepartmentPayrollParams) ([]GetDepartmentPayrollRow, error) {
	rows, err := q.db.QueryContext(ctx, getDepartmentPayroll,
		arg.DeptNo,
		arg.ValidFrom,
		arg.ValidTo,
		arg.ValidFrom_2,
		arg.ValidTo_2,
		arg.ValidFrom_3,
		arg.ValidTo_3,
		arg.ValidFrom_4,
		arg.ValidTo_4,
		arg.ValidFrom_5,
		arg.ValidTo_5,
		arg.ValidFrom_6,
		arg.ValidTo_6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDepartmentPayrollRow
	for rows.Next() {
		var i GetDepartmentPayrollRow
		if err := rows.Scan(
			&i.EmpNo,
			&i.FirstName,
			&i.LastName,
			&i.Title,
			&i.Salary,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeAuditTrail = `-- name: GetEmployeeAuditTrail :many
SELECT 
  'employee' as change_type,
  transaction_time,
  valid_from,
  valid_to,
  first_name || ' ' || last_name as description
FROM employees 
WHERE employees.emp_no = ?
UNION ALL
SELECT 
  'department' as change_type,
  de.transaction_time,
  de.valid_from,
  de.valid_to,
  'Assigned to ' || d.dept_name as description
FROM dept_emp de
JOIN departments d ON de.dept_no = d.dept_no
WHERE de.emp_no = ?
UNION ALL
SELECT 
  'title' as change_type,
  transaction_time,
  valid_from,
  valid_to,
  'Title: ' || title as description
FROM titles
WHERE titles.emp_no = ?
UNION ALL
SELECT 
  'salary' as change_type,
  transaction_time,
  valid_from,
  valid_to,
  'Salary: $' || salary as description
FROM salaries
WHERE salaries.emp_no = ?
UNION ALL
SELECT 
  'management' as change_type,
  dm.transaction_time,
  dm.valid_from,
  dm.valid_to,
  'Manager of ' || d.dept_name as description
FROM dept_manager dm
JOIN departments d ON dm.dept_no = d.dept_no
WHERE dm.emp_no = ?
ORDER BY transaction_time DESC, valid_from DESC
`

type GetEmployeeAuditTrailParams struct {
	EmpNo   int64 `json:"emp_no"`
	EmpNo_2 int64 `json:"emp_no_2"`
	EmpNo_3 int64 `json:"emp_no_3"`
	EmpNo_4 int64 `json:"emp_no_4"`
	EmpNo_5 int64 `json:"emp_no_5"`
}

type GetEmployeeAuditTrailRow struct {
	ChangeType      string       `json:"change_type"`
	TransactionTime sql.NullTime `json:"transaction_time"`
	ValidFrom       time.Time    `json:"valid_from"`
	ValidTo         time.Time    `json:"valid_to"`
	Description     interface{}  `json:"description"`
}

// Get all changes for an employee (audit trail)
func (q *Queries) GetEmployeeAuditTrail(ctx context.Context, arg GetEmployeeAuditTrailParams) ([]GetEmployeeAuditTrailRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeAuditTrail,
		arg.EmpNo,
		arg.EmpNo_2,
		arg.EmpNo_3,
		arg.EmpNo_4,
		arg.EmpNo_5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeeAuditTrailRow
	for rows.Next() {
		var i GetEmployeeAuditTrailRow
		if err := rows.Scan(
			&i.ChangeType,
			&i.TransactionTime,
			&i.ValidFrom,
			&i.ValidTo,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeProfile = `-- name: GetEmployeeProfile :one

SELECT 
  e.emp_no, e.first_name, e.last_name, e.birth_date, e.gender, e.hire_date,
  d.dept_no, d.dept_name,
  t.title,
  s.salary,
  CASE WHEN dm.emp_no IS NOT NULL THEN 1 ELSE 0 END as is_manager
FROM employees e
LEFT JOIN dept_emp de ON e.emp_no = de.emp_no 
  AND de.valid_from <= ? AND de.valid_to > ?
LEFT JOIN departments d ON de.dept_no = d.dept_no
  AND d.valid_from <= ? AND d.valid_to > ?
LEFT JOIN titles t ON e.emp_no = t.emp_no
  AND t.valid_from <= ? AND t.valid_to > ?
LEFT JOIN salaries s ON e.emp_no = s.emp_no
  AND s.valid_from <= ? AND s.valid_to > ?
LEFT JOIN dept_manager dm ON e.emp_no = dm.emp_no
  AND dm.valid_from <= ? AND dm.valid_to > ?
WHERE e.emp_no = ?
  AND e.valid_from <= ? AND e.valid_to > ?
ORDER BY de.transaction_time DESC, t.transaction_time DESC, s.transaction_time DESC
LIMIT 1
`

type GetEmployeeProfileParams struct {
	ValidFrom   time.Time `json:"valid_from"`
	ValidTo     time.Time `json:"valid_to"`
	ValidFrom_2 time.Time `json:"valid_from_2"`
	ValidTo_2   time.Time `json:"valid_to_2"`
	ValidFrom_3 time.Time `json:"valid_from_3"`
	ValidTo_3   time.Time `json:"valid_to_3"`
	ValidFrom_4 time.Time `json:"valid_from_4"`
	ValidTo_4   time.Time `json:"valid_to_4"`
	ValidFrom_5 time.Time `json:"valid_from_5"`
	ValidTo_5   time.Time `json:"valid_to_5"`
	EmpNo       int64     `json:"emp_no"`
	ValidFrom_6 time.Time `json:"valid_from_6"`
	ValidTo_6   time.Time `json:"valid_to_6"`
}

type GetEmployeeProfileRow struct {
	EmpNo     int64          `json:"emp_no"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	BirthDate time.Time      `json:"birth_date"`
	Gender    string         `json:"gender"`
	HireDate  time.Time      `json:"hire_date"`
	DeptNo    sql.NullString `json:"dept_no"`
	DeptName  sql.NullString `json:"dept_name"`
	Title     sql.NullString `json:"title"`
	Salary    sql.NullInt64  `json:"salary"`
	IsManager int64          `json:"is_manager"`
}

// Advanced Bitemporal Queries Across Multiple Tables
// Get complete employee profile with current department, title, and salary
func (q *Queries) GetEmployeeProfile(ctx context.Context, arg GetEmployeeProfileParams) (GetEmployeeProfileRow, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeProfile,
		arg.ValidFrom,
		arg.ValidTo,
		arg.ValidFrom_2,
		arg.ValidTo_2,
		arg.ValidFrom_3,
		arg.ValidTo_3,
		arg.ValidFrom_4,
		arg.ValidTo_4,
		arg.ValidFrom_5,
		arg.ValidTo_5,
		arg.EmpNo,
		arg.ValidFrom_6,
		arg.ValidTo_6,
	)
	var i GetEmployeeProfileRow
	err := row.Scan(
		&i.EmpNo,
		&i.FirstName,
		&i.LastName,
		&i.BirthDate,
		&i.Gender,
		&i.HireDate,
		&i.DeptNo,
		&i.DeptName,
		&i.Title,
		&i.Salary,
		&i.IsManager,
	)
	return i, err
}

const getEmployeeProfileTimeTravel = `-- name: GetEmployeeProfileTimeTravel :one
SELECT 
  e.emp_no, e.first_name, e.last_name, e.birth_date, e.gender, e.hire_date,
  d.dept_no, d.dept_name,
  t.title,
  s.salary,
  CASE WHEN dm.emp_no IS NOT NULL THEN 1 ELSE 0 END as is_manager
FROM employees e
LEFT JOIN dept_emp de ON e.emp_no = de.emp_no 
  AND de.transaction_time <= ? AND de.valid_from <= ? AND de.valid_to > ?
LEFT JOIN departments d ON de.dept_no = d.dept_no
  AND d.transaction_time <= ? AND d.valid_from <= ? AND d.valid_to > ?
LEFT JOIN titles t ON e.emp_no = t.emp_no
  AND t.transaction_time <= ? AND t.valid_from <= ? AND t.valid_to > ?
LEFT JOIN salaries s ON e.emp_no = s.emp_no
  AND s.transaction_time <= ? AND s.valid_from <= ? AND s.valid_to > ?
LEFT JOIN dept_manager dm ON e.emp_no = dm.emp_no
  AND dm.transaction_time <= ? AND dm.valid_from <= ? AND dm.valid_to > ?
WHERE e.emp_no = ?
  AND e.transaction_time <= ? AND e.valid_from <= ? AND e.valid_to > ?
ORDER BY e.transaction_time DESC, de.transaction_time DESC, t.transaction_time DESC, s.transaction_time DESC
LIMIT 1
`

type GetEmployeeProfileTimeTravelParams struct {
	TransactionTime   sql.NullTime `json:"transaction_time"`
	ValidFrom         time.Time    `json:"valid_from"`
	ValidTo           time.Time    `json:"valid_to"`
	TransactionTime_2 sql.NullTime `json:"transaction_time_2"`
	ValidFrom_2       time.Time    `json:"valid_from_2"`
	ValidTo_2         time.Time    `json:"valid_to_2"`
	TransactionTime_3 sql.NullTime `json:"transaction_time_3"`
	ValidFrom_3       time.Time    `json:"valid_from_3"`
	ValidTo_3         time.Time    `json:"valid_to_3"`
	TransactionTime_4 sql.NullTime `json:"transaction_time_4"`
	ValidFrom_4       time.Time    `json:"valid_from_4"`
	ValidTo_4         time.Time    `json:"valid_to_4"`
	TransactionTime_5 sql.NullTime `json:"transaction_time_5"`
	ValidFrom_5       time.Time    `json:"valid_from_5"`
	ValidTo_5         time.Time    `json:"valid_to_5"`
	EmpNo             int64        `json:"emp_no"`
	TransactionTime_6 sql.NullTime `json:"transaction_time_6"`
	ValidFrom_6       time.Time    `json:"valid_from_6"`
	ValidTo_6         time.Time    `json:"valid_to_6"`
}

type GetEmployeeProfileTimeTravelRow struct {
	EmpNo     int64          `json:"emp_no"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	BirthDate time.Time      `json:"birth_date"`
	Gender    string         `json:"gender"`
	HireDate  time.Time      `json:"hire_date"`
	DeptNo    sql.NullString `json:"dept_no"`
	DeptName  sql.NullString `json:"dept_name"`
	Title     sql.NullString `json:"title"`
	Salary    sql.NullInt64  `json:"salary"`
	IsManager int64          `json:"is_manager"`
}

// Get employee profile as it existed at specific transaction time (time travel)
func (q *Queries) GetEmployeeProfileTimeTravel(ctx context.Context, arg GetEmployeeProfileTimeTravelParams) (GetEmployeeProfileTimeTravelRow, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeProfileTimeTravel,
		arg.TransactionTime,
		arg.ValidFrom,
		arg.ValidTo,
		arg.TransactionTime_2,
		arg.ValidFrom_2,
		arg.ValidTo_2,
		arg.TransactionTime_3,
		arg.ValidFrom_3,
		arg.ValidTo_3,
		arg.TransactionTime_4,
		arg.ValidFrom_4,
		arg.ValidTo_4,
		arg.TransactionTime_5,
		arg.ValidFrom_5,
		arg.ValidTo_5,
		arg.EmpNo,
		arg.TransactionTime_6,
		arg.ValidFrom_6,
		arg.ValidTo_6,
	)
	var i GetEmployeeProfileTimeTravelRow
	err := row.Scan(
		&i.EmpNo,
		&i.FirstName,
		&i.LastName,
		&i.BirthDate,
		&i.Gender,
		&i.HireDate,
		&i.DeptNo,
		&i.DeptName,
		&i.Title,
		&i.Salary,
		&i.IsManager,
	)
	return i, err
}

const getEmployeesWithOverlappingRoles = `-- name: GetEmployeesWithOverlappingRoles :many
SELECT DISTINCT
  e.emp_no, e.first_name, e.last_name,
  COUNT(DISTINCT de.dept_no) as dept_count,
  COUNT(DISTINCT t.title) as title_count
FROM employees e
JOIN dept_emp de ON e.emp_no = de.emp_no
JOIN titles t ON e.emp_no = t.emp_no
WHERE de.valid_from <= ? AND de.valid_to > ?
  AND t.valid_from <= ? AND t.valid_to > ?
  AND e.valid_from <= ? AND e.valid_to > ?
GROUP BY e.emp_no, e.first_name, e.last_name
HAVING COUNT(DISTINCT de.dept_no) > 1 OR COUNT(DISTINCT t.title) > 1
ORDER BY dept_count DESC, title_count DESC
`

type GetEmployeesWithOverlappingRolesParams struct {
	ValidFrom   time.Time `json:"valid_from"`
	ValidTo     time.Time `json:"valid_to"`
	ValidFrom_2 time.Time `json:"valid_from_2"`
	ValidTo_2   time.Time `json:"valid_to_2"`
	ValidFrom_3 time.Time `json:"valid_from_3"`
	ValidTo_3   time.Time `json:"valid_to_3"`
}

type GetEmployeesWithOverlappingRolesRow struct {
	EmpNo      int64  `json:"emp_no"`
	FirstName  string `json:"first_name"`
	LastName   string `json:"last_name"`
	DeptCount  int64  `json:"dept_count"`
	TitleCount int64  `json:"title_count"`
}

// Find employees who held multiple positions simultaneously
func (q *Queries) GetEmployeesWithOverlappingRoles(ctx context.Context, arg GetEmployeesWithOverlappingRolesParams) ([]GetEmployeesWithOverlappingRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeesWithOverlappingRoles,
		arg.ValidFrom,
		arg.ValidTo,
		arg.ValidFrom_2,
		arg.ValidTo_2,
		arg.ValidFrom_3,
		arg.ValidTo_3,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeesWithOverlappingRolesRow
	for rows.Next() {
		var i GetEmployeesWithOverlappingRolesRow
		if err := rows.Scan(
			&i.EmpNo,
			&i.FirstName,
			&i.LastName,
			&i.DeptCount,
			&i.TitleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
