// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: titles.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const closeEmployeeTitleValidPeriod = `-- name: CloseEmployeeTitleValidPeriod :exec
UPDATE titles 
SET valid_to = ?
WHERE emp_no = ?
  AND valid_to = '9999-12-31 23:59:59'
`

type CloseEmployeeTitleValidPeriodParams struct {
	ValidTo time.Time `json:"valid_to"`
	EmpNo   int64     `json:"emp_no"`
}

// Close current title (used before promotion/change)
func (q *Queries) CloseEmployeeTitleValidPeriod(ctx context.Context, arg CloseEmployeeTitleValidPeriodParams) error {
	_, err := q.db.ExecContext(ctx, closeEmployeeTitleValidPeriod, arg.ValidTo, arg.EmpNo)
	return err
}

const closeSpecificTitleAssignment = `-- name: CloseSpecificTitleAssignment :exec
UPDATE titles 
SET valid_to = ?
WHERE emp_no = ?
  AND title = ?
  AND valid_to = '9999-12-31 23:59:59'
`

type CloseSpecificTitleAssignmentParams struct {
	ValidTo time.Time `json:"valid_to"`
	EmpNo   int64     `json:"emp_no"`
	Title   string    `json:"title"`
}

// Close specific title assignment
func (q *Queries) CloseSpecificTitleAssignment(ctx context.Context, arg CloseSpecificTitleAssignmentParams) error {
	_, err := q.db.ExecContext(ctx, closeSpecificTitleAssignment, arg.ValidTo, arg.EmpNo, arg.Title)
	return err
}

const countEmployeesByTitle = `-- name: CountEmployeesByTitle :many
SELECT title, COUNT(*) as employee_count
FROM titles
WHERE valid_from <= ?
  AND valid_to > ?
GROUP BY title
ORDER BY employee_count DESC
`

type CountEmployeesByTitleParams struct {
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

type CountEmployeesByTitleRow struct {
	Title         string `json:"title"`
	EmployeeCount int64  `json:"employee_count"`
}

// Count employees by title (current)
func (q *Queries) CountEmployeesByTitle(ctx context.Context, arg CountEmployeesByTitleParams) ([]CountEmployeesByTitleRow, error) {
	rows, err := q.db.QueryContext(ctx, countEmployeesByTitle, arg.ValidFrom, arg.ValidTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountEmployeesByTitleRow
	for rows.Next() {
		var i CountEmployeesByTitleRow
		if err := rows.Scan(&i.Title, &i.EmployeeCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createTitle = `-- name: CreateTitle :one
INSERT INTO titles (
  emp_no, title, valid_from, valid_to
) VALUES (
  ?, ?, ?, ?
)
RETURNING emp_no, title, valid_from, valid_to, transaction_time
`

type CreateTitleParams struct {
	EmpNo     int64     `json:"emp_no"`
	Title     string    `json:"title"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Create new title assignment
func (q *Queries) CreateTitle(ctx context.Context, arg CreateTitleParams) (Title, error) {
	row := q.db.QueryRowContext(ctx, createTitle,
		arg.EmpNo,
		arg.Title,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i Title
	err := row.Scan(
		&i.EmpNo,
		&i.Title,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const getEmployeeTitleAsOfTransaction = `-- name: GetEmployeeTitleAsOfTransaction :one
SELECT emp_no, title, valid_from, valid_to, transaction_time FROM titles
WHERE emp_no = ?
  AND transaction_time <= ?
  AND valid_from <= ?
  AND valid_to > ?
ORDER BY transaction_time DESC
LIMIT 1
`

type GetEmployeeTitleAsOfTransactionParams struct {
	EmpNo           int64        `json:"emp_no"`
	TransactionTime sql.NullTime `json:"transaction_time"`
	ValidFrom       time.Time    `json:"valid_from"`
	ValidTo         time.Time    `json:"valid_to"`
}

// Get employee title as it was known at specific transaction time
func (q *Queries) GetEmployeeTitleAsOfTransaction(ctx context.Context, arg GetEmployeeTitleAsOfTransactionParams) (Title, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeTitleAsOfTransaction,
		arg.EmpNo,
		arg.TransactionTime,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i Title
	err := row.Scan(
		&i.EmpNo,
		&i.Title,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const getEmployeeTitleCurrent = `-- name: GetEmployeeTitleCurrent :one

SELECT emp_no, title, valid_from, valid_to, transaction_time FROM titles
WHERE emp_no = ? 
  AND valid_from <= ? 
  AND valid_to > ?
ORDER BY transaction_time DESC
LIMIT 1
`

type GetEmployeeTitleCurrentParams struct {
	EmpNo     int64     `json:"emp_no"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Bitemporal Employee Title Queries
// Get current title for employee
func (q *Queries) GetEmployeeTitleCurrent(ctx context.Context, arg GetEmployeeTitleCurrentParams) (Title, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeTitleCurrent, arg.EmpNo, arg.ValidFrom, arg.ValidTo)
	var i Title
	err := row.Scan(
		&i.EmpNo,
		&i.Title,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const getEmployeeTitleHistory = `-- name: GetEmployeeTitleHistory :many
SELECT emp_no, title, valid_from, valid_to, transaction_time FROM titles
WHERE emp_no = ?
ORDER BY valid_from, transaction_time
`

// Get complete history of titles for employee
func (q *Queries) GetEmployeeTitleHistory(ctx context.Context, empNo int64) ([]Title, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeTitleHistory, empNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Title
	for rows.Next() {
		var i Title
		if err := rows.Scan(
			&i.EmpNo,
			&i.Title,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeesByTitleCurrent = `-- name: GetEmployeesByTitleCurrent :many
SELECT emp_no, title, valid_from, valid_to, transaction_time FROM titles
WHERE title = ?
  AND valid_from <= ?
  AND valid_to > ?
ORDER BY emp_no
`

type GetEmployeesByTitleCurrentParams struct {
	Title     string    `json:"title"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Get all employees with specific title (current)
func (q *Queries) GetEmployeesByTitleCurrent(ctx context.Context, arg GetEmployeesByTitleCurrentParams) ([]Title, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeesByTitleCurrent, arg.Title, arg.ValidFrom, arg.ValidTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Title
	for rows.Next() {
		var i Title
		if err := rows.Scan(
			&i.EmpNo,
			&i.Title,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPromotionsToTitle = `-- name: GetPromotionsToTitle :many
SELECT t2.emp_no, t1.title as from_title, t2.title as to_title,
       t2.valid_from as promotion_date
FROM titles t1
JOIN titles t2 ON t1.emp_no = t2.emp_no
WHERE t2.title = ?
  AND t2.valid_from BETWEEN ? AND ?
  AND t1.valid_to = t2.valid_from
  AND t1.title != t2.title
ORDER BY t2.valid_from, t2.emp_no
`

type GetPromotionsToTitleRow struct {
	EmpNo         int64     `json:"emp_no"`
	FromTitle     string    `json:"from_title"`
	ToTitle       string    `json:"to_title"`
	PromotionDate time.Time `json:"promotion_date"`
}

// Get employees promoted to specific title in date range
func (q *Queries) GetPromotionsToTitle(ctx context.Context, title string) ([]GetPromotionsToTitleRow, error) {
	rows, err := q.db.QueryContext(ctx, getPromotionsToTitle, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPromotionsToTitleRow
	for rows.Next() {
		var i GetPromotionsToTitleRow
		if err := rows.Scan(
			&i.EmpNo,
			&i.FromTitle,
			&i.ToTitle,
			&i.PromotionDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTitleChanges = `-- name: GetTitleChanges :many
SELECT t1.emp_no, t1.title as old_title, t2.title as new_title,
       t1.valid_to as change_date
FROM titles t1
JOIN titles t2 ON t1.emp_no = t2.emp_no
WHERE t1.valid_to BETWEEN ? AND ?
  AND t2.valid_from = t1.valid_to
  AND t1.title != t2.title
ORDER BY t1.valid_to, t1.emp_no
`

type GetTitleChangesParams struct {
	ValidTo   time.Time `json:"valid_to"`
	ValidTo_2 time.Time `json:"valid_to_2"`
	ValidTo_3 time.Time `json:"valid_to_3"`
	ValidTo_4 time.Time `json:"valid_to_4"`
}

type GetTitleChangesRow struct {
	EmpNo      int64     `json:"emp_no"`
	OldTitle   string    `json:"old_title"`
	NewTitle   string    `json:"new_title"`
	ChangeDate time.Time `json:"change_date"`
}

// Get title changes (promotions/demotions) in date range
func (q *Queries) GetTitleChanges(ctx context.Context, arg GetTitleChangesParams) ([]GetTitleChangesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTitleChanges,
		arg.ValidTo,
		arg.ValidTo_2,
		arg.ValidTo_3,
		arg.ValidTo_4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTitleChangesRow
	for rows.Next() {
		var i GetTitleChangesRow
		if err := rows.Scan(
			&i.EmpNo,
			&i.OldTitle,
			&i.NewTitle,
			&i.ChangeDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTitleUpdate = `-- name: InsertTitleUpdate :one
INSERT INTO titles (
  emp_no, title, valid_from, valid_to
) VALUES (
  ?, ?, ?, ?
)
RETURNING emp_no, title, valid_from, valid_to, transaction_time
`

type InsertTitleUpdateParams struct {
	EmpNo     int64     `json:"emp_no"`
	Title     string    `json:"title"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Insert updated title assignment (promotion/demotion)
func (q *Queries) InsertTitleUpdate(ctx context.Context, arg InsertTitleUpdateParams) (Title, error) {
	row := q.db.QueryRowContext(ctx, insertTitleUpdate,
		arg.EmpNo,
		arg.Title,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i Title
	err := row.Scan(
		&i.EmpNo,
		&i.Title,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const listCurrentTitles = `-- name: ListCurrentTitles :many
SELECT DISTINCT title FROM titles
WHERE valid_from <= ?
  AND valid_to > ?
ORDER BY title
`

type ListCurrentTitlesParams struct {
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Get all current titles
func (q *Queries) ListCurrentTitles(ctx context.Context, arg ListCurrentTitlesParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listCurrentTitles, arg.ValidFrom, arg.ValidTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var title string
		if err := rows.Scan(&title); err != nil {
			return nil, err
		}
		items = append(items, title)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTitlesAsOfTransaction = `-- name: ListTitlesAsOfTransaction :many
SELECT DISTINCT emp_no, title, valid_from, valid_to, transaction_time
FROM titles t1
WHERE t1.transaction_time <= ?
  AND t1.valid_from <= ?
  AND t1.valid_to > ?
  AND t1.transaction_time = (
    SELECT MAX(t2.transaction_time)
    FROM titles t2
    WHERE t2.emp_no = t1.emp_no
      AND t2.title = t1.title
      AND t2.transaction_time <= ?
  )
ORDER BY emp_no, title
`

type ListTitlesAsOfTransactionParams struct {
	TransactionTime   sql.NullTime `json:"transaction_time"`
	ValidFrom         time.Time    `json:"valid_from"`
	ValidTo           time.Time    `json:"valid_to"`
	TransactionTime_2 sql.NullTime `json:"transaction_time_2"`
}

// Get title assignments as they existed at specific transaction time
func (q *Queries) ListTitlesAsOfTransaction(ctx context.Context, arg ListTitlesAsOfTransactionParams) ([]Title, error) {
	rows, err := q.db.QueryContext(ctx, listTitlesAsOfTransaction,
		arg.TransactionTime,
		arg.ValidFrom,
		arg.ValidTo,
		arg.TransactionTime_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Title
	for rows.Next() {
		var i Title
		if err := rows.Scan(
			&i.EmpNo,
			&i.Title,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
