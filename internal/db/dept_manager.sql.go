// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dept_manager.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const closeDeptManagerValidPeriod = `-- name: CloseDeptManagerValidPeriod :exec
UPDATE dept_manager 
SET valid_to = ?
WHERE dept_no = ?
  AND valid_to = '9999-12-31 23:59:59'
`

type CloseDeptManagerValidPeriodParams struct {
	ValidTo time.Time `json:"valid_to"`
	DeptNo  string    `json:"dept_no"`
}

// Close current manager assignment (used before replacement)
func (q *Queries) CloseDeptManagerValidPeriod(ctx context.Context, arg CloseDeptManagerValidPeriodParams) error {
	_, err := q.db.ExecContext(ctx, closeDeptManagerValidPeriod, arg.ValidTo, arg.DeptNo)
	return err
}

const closeSpecificManagerAssignment = `-- name: CloseSpecificManagerAssignment :exec
UPDATE dept_manager 
SET valid_to = ?
WHERE emp_no = ?
  AND dept_no = ?
  AND valid_to = '9999-12-31 23:59:59'
`

type CloseSpecificManagerAssignmentParams struct {
	ValidTo time.Time `json:"valid_to"`
	EmpNo   int64     `json:"emp_no"`
	DeptNo  string    `json:"dept_no"`
}

// Close specific manager assignment
func (q *Queries) CloseSpecificManagerAssignment(ctx context.Context, arg CloseSpecificManagerAssignmentParams) error {
	_, err := q.db.ExecContext(ctx, closeSpecificManagerAssignment, arg.ValidTo, arg.EmpNo, arg.DeptNo)
	return err
}

const createDeptManager = `-- name: CreateDeptManager :one
INSERT INTO dept_manager (
  emp_no, dept_no, valid_from, valid_to
) VALUES (
  ?, ?, ?, ?
)
RETURNING emp_no, dept_no, valid_from, valid_to, transaction_time
`

type CreateDeptManagerParams struct {
	EmpNo     int64     `json:"emp_no"`
	DeptNo    string    `json:"dept_no"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Create new department manager assignment
func (q *Queries) CreateDeptManager(ctx context.Context, arg CreateDeptManagerParams) (DeptManager, error) {
	row := q.db.QueryRowContext(ctx, createDeptManager,
		arg.EmpNo,
		arg.DeptNo,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i DeptManager
	err := row.Scan(
		&i.EmpNo,
		&i.DeptNo,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const getDepartmentManagerAsOfTransaction = `-- name: GetDepartmentManagerAsOfTransaction :one
SELECT emp_no, dept_no, valid_from, valid_to, transaction_time FROM dept_manager
WHERE dept_no = ?
  AND transaction_time <= ?
  AND valid_from <= ?
  AND valid_to > ?
ORDER BY transaction_time DESC
LIMIT 1
`

type GetDepartmentManagerAsOfTransactionParams struct {
	DeptNo          string       `json:"dept_no"`
	TransactionTime sql.NullTime `json:"transaction_time"`
	ValidFrom       time.Time    `json:"valid_from"`
	ValidTo         time.Time    `json:"valid_to"`
}

// Get department manager as it was known at specific transaction time
func (q *Queries) GetDepartmentManagerAsOfTransaction(ctx context.Context, arg GetDepartmentManagerAsOfTransactionParams) (DeptManager, error) {
	row := q.db.QueryRowContext(ctx, getDepartmentManagerAsOfTransaction,
		arg.DeptNo,
		arg.TransactionTime,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i DeptManager
	err := row.Scan(
		&i.EmpNo,
		&i.DeptNo,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const getDepartmentManagerCurrent = `-- name: GetDepartmentManagerCurrent :one

SELECT emp_no, dept_no, valid_from, valid_to, transaction_time FROM dept_manager
WHERE dept_no = ? 
  AND valid_from <= ? 
  AND valid_to > ?
ORDER BY transaction_time DESC
LIMIT 1
`

type GetDepartmentManagerCurrentParams struct {
	DeptNo    string    `json:"dept_no"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Bitemporal Department Manager Queries
// Get current manager for department
func (q *Queries) GetDepartmentManagerCurrent(ctx context.Context, arg GetDepartmentManagerCurrentParams) (DeptManager, error) {
	row := q.db.QueryRowContext(ctx, getDepartmentManagerCurrent, arg.DeptNo, arg.ValidFrom, arg.ValidTo)
	var i DeptManager
	err := row.Scan(
		&i.EmpNo,
		&i.DeptNo,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const getDepartmentManagerHistory = `-- name: GetDepartmentManagerHistory :many
SELECT emp_no, dept_no, valid_from, valid_to, transaction_time FROM dept_manager
WHERE dept_no = ?
ORDER BY valid_from, transaction_time
`

// Get complete history of managers for department
func (q *Queries) GetDepartmentManagerHistory(ctx context.Context, deptNo string) ([]DeptManager, error) {
	rows, err := q.db.QueryContext(ctx, getDepartmentManagerHistory, deptNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeptManager
	for rows.Next() {
		var i DeptManager
		if err := rows.Scan(
			&i.EmpNo,
			&i.DeptNo,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDepartmentsWithoutManager = `-- name: GetDepartmentsWithoutManager :many
SELECT d.dept_no, d.dept_name, d.valid_from, d.valid_to, d.transaction_time
FROM departments d
WHERE d.valid_from <= ?
  AND d.valid_to > ?
  AND NOT EXISTS (
    SELECT 1 FROM dept_manager dm
    WHERE dm.dept_no = d.dept_no
      AND dm.valid_from <= ?
      AND dm.valid_to > ?
  )
`

type GetDepartmentsWithoutManagerParams struct {
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Get departments with no current manager
func (q *Queries) GetDepartmentsWithoutManager(ctx context.Context, arg GetDepartmentsWithoutManagerParams) ([]Department, error) {
	rows, err := q.db.QueryContext(ctx, getDepartmentsWithoutManager, arg.ValidFrom, arg.ValidTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Department
	for rows.Next() {
		var i Department
		if err := rows.Scan(
			&i.DeptNo,
			&i.DeptName,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeManagementCurrent = `-- name: GetEmployeeManagementCurrent :many
SELECT emp_no, dept_no, valid_from, valid_to, transaction_time FROM dept_manager
WHERE emp_no = ?
  AND valid_from <= ?
  AND valid_to > ?
ORDER BY dept_no
`

type GetEmployeeManagementCurrentParams struct {
	EmpNo     int64     `json:"emp_no"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Get all departments managed by employee (current)
func (q *Queries) GetEmployeeManagementCurrent(ctx context.Context, arg GetEmployeeManagementCurrentParams) ([]DeptManager, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeManagementCurrent, arg.EmpNo, arg.ValidFrom, arg.ValidTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeptManager
	for rows.Next() {
		var i DeptManager
		if err := rows.Scan(
			&i.EmpNo,
			&i.DeptNo,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManagerChanges = `-- name: GetManagerChanges :many
SELECT dm1.dept_no, dm1.emp_no as old_manager, dm2.emp_no as new_manager,
       dm1.valid_to as change_date
FROM dept_manager dm1
JOIN dept_manager dm2 ON dm1.dept_no = dm2.dept_no
WHERE dm1.valid_to BETWEEN ? AND ?
  AND dm2.valid_from = dm1.valid_to
  AND dm1.emp_no != dm2.emp_no
ORDER BY dm1.valid_to, dm1.dept_no
`

type GetManagerChangesParams struct {
	ValidTo   time.Time `json:"valid_to"`
	ValidTo_2 time.Time `json:"valid_to_2"`
	ValidTo_3 time.Time `json:"valid_to_3"`
	ValidTo_4 time.Time `json:"valid_to_4"`
}

type GetManagerChangesRow struct {
	DeptNo     string    `json:"dept_no"`
	OldManager int64     `json:"old_manager"`
	NewManager int64     `json:"new_manager"`
	ChangeDate time.Time `json:"change_date"`
}

// Get manager changes in date range
func (q *Queries) GetManagerChanges(ctx context.Context, arg GetManagerChangesParams) ([]GetManagerChangesRow, error) {
	rows, err := q.db.QueryContext(ctx, getManagerChanges,
		arg.ValidTo,
		arg.ValidTo_2,
		arg.ValidTo_3,
		arg.ValidTo_4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetManagerChangesRow
	for rows.Next() {
		var i GetManagerChangesRow
		if err := rows.Scan(
			&i.DeptNo,
			&i.OldManager,
			&i.NewManager,
			&i.ChangeDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDeptManagerUpdate = `-- name: InsertDeptManagerUpdate :one
INSERT INTO dept_manager (
  emp_no, dept_no, valid_from, valid_to
) VALUES (
  ?, ?, ?, ?
)
RETURNING emp_no, dept_no, valid_from, valid_to, transaction_time
`

type InsertDeptManagerUpdateParams struct {
	EmpNo     int64     `json:"emp_no"`
	DeptNo    string    `json:"dept_no"`
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Insert updated manager assignment
func (q *Queries) InsertDeptManagerUpdate(ctx context.Context, arg InsertDeptManagerUpdateParams) (DeptManager, error) {
	row := q.db.QueryRowContext(ctx, insertDeptManagerUpdate,
		arg.EmpNo,
		arg.DeptNo,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i DeptManager
	err := row.Scan(
		&i.EmpNo,
		&i.DeptNo,
		&i.ValidFrom,
		&i.ValidTo,
		&i.TransactionTime,
	)
	return i, err
}

const listCurrentManagers = `-- name: ListCurrentManagers :many
SELECT emp_no, dept_no, valid_from, valid_to, transaction_time FROM dept_manager
WHERE valid_from <= ?
  AND valid_to > ?
ORDER BY dept_no
`

type ListCurrentManagersParams struct {
	ValidFrom time.Time `json:"valid_from"`
	ValidTo   time.Time `json:"valid_to"`
}

// Get all current department managers
func (q *Queries) ListCurrentManagers(ctx context.Context, arg ListCurrentManagersParams) ([]DeptManager, error) {
	rows, err := q.db.QueryContext(ctx, listCurrentManagers, arg.ValidFrom, arg.ValidTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeptManager
	for rows.Next() {
		var i DeptManager
		if err := rows.Scan(
			&i.EmpNo,
			&i.DeptNo,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listManagersAsOfTransaction = `-- name: ListManagersAsOfTransaction :many
SELECT DISTINCT emp_no, dept_no, valid_from, valid_to, transaction_time
FROM dept_manager dm1
WHERE dm1.transaction_time <= ?
  AND dm1.valid_from <= ?
  AND dm1.valid_to > ?
  AND dm1.transaction_time = (
    SELECT MAX(dm2.transaction_time)
    FROM dept_manager dm2
    WHERE dm2.emp_no = dm1.emp_no
      AND dm2.dept_no = dm1.dept_no
      AND dm2.transaction_time <= ?
  )
ORDER BY dept_no
`

type ListManagersAsOfTransactionParams struct {
	TransactionTime   sql.NullTime `json:"transaction_time"`
	ValidFrom         time.Time    `json:"valid_from"`
	ValidTo           time.Time    `json:"valid_to"`
	TransactionTime_2 sql.NullTime `json:"transaction_time_2"`
}

// Get department managers as they existed at specific transaction time
func (q *Queries) ListManagersAsOfTransaction(ctx context.Context, arg ListManagersAsOfTransactionParams) ([]DeptManager, error) {
	rows, err := q.db.QueryContext(ctx, listManagersAsOfTransaction,
		arg.TransactionTime,
		arg.ValidFrom,
		arg.ValidTo,
		arg.TransactionTime_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeptManager
	for rows.Next() {
		var i DeptManager
		if err := rows.Scan(
			&i.EmpNo,
			&i.DeptNo,
			&i.ValidFrom,
			&i.ValidTo,
			&i.TransactionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
